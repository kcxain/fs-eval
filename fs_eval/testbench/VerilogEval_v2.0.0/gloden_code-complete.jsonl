{"task_id": "Prob131_mt2015_q4", "glodcode": "\nmodule RefModule (\n  input x,\n  input y,\n  output z\n);\n\n  assign z = x|~y;\n\nendmodule\n\n"}
{"task_id": "Prob104_mt2015_muxdff", "glodcode": "\nmodule RefModule (\n  input clk,\n  input L,\n  input q_in,\n  input r_in,\n  output reg Q\n);\n\n  initial Q=0;\n  always @(posedge clk)\n    Q <= L ? r_in : q_in;\n\nendmodule\n\n"}
{"task_id": "Prob080_timer", "glodcode": "\nmodule RefModule (\n  input clk,\n  input load,\n  input [9:0] data,\n  output tc\n);\n\n  logic [9:0] count_value;\n\n  always @(posedge clk)\n    if(load) count_value <= data;\n    else if(count_value != 0) count_value <= count_value - 1;\n\n  assign tc = count_value == 0;\n\nendmodule\n\n"}
{"task_id": "Prob135_m2014_q6b", "glodcode": "\nmodule RefModule (\n  input [3:1] y,\n  input w,\n  output reg Y2\n);\n\n  always_comb begin\n    case ({y, w})\n      4'h0: Y2 = 1'b0;\n      4'h1: Y2 = 1'b0;\n      4'h2: Y2 = 1'b1;\n      4'h3: Y2 = 1'b1;\n      4'h4: Y2 = 1'b0;\n      4'h5: Y2 = 1'b1;\n      4'h6: Y2 = 1'b0;\n      4'h7: Y2 = 1'b0;\n      4'h8: Y2 = 1'b0;\n      4'h9: Y2 = 1'b1;\n      4'ha: Y2 = 1'b1;\n      4'hb: Y2 = 1'b1;\n      default: Y2 = 1'bx;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob111_fsm2s", "glodcode": "\nmodule RefModule (\n  input clk,\n  input j,\n  input k,\n  input reset,\n  output out\n);\n\n  parameter A=0, B=1;\n  reg state;\n  reg next;\n\n    always_comb begin\n    case (state)\n      A: next = j ? B : A;\n      B: next = k ? A : B;\n    endcase\n    end\n\n    always @(posedge clk) begin\n    if (reset) state <= A;\n        else state <= next;\n  end\n\n  assign out = (state==B);\n\nendmodule\n\n"}
{"task_id": "Prob096_review2015_fsmseq", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  input data,\n  output start_shifting\n);\n\n  parameter S=0, S1=1, S11=2, S110=3, Done=4;\n\n  reg [2:0] state, next;\n\n  always_comb begin\n    case (state)\n      S: next = data ? S1: S;\n      S1: next = data ? S11: S;\n      S11: next = data ? S11 : S110;\n      S110: next = data ? Done : S;\n      Done: next = Done;\n    endcase\n  end\n\n  always @(posedge clk)\n    if (reset) state <= S;\n    else state <= next;\n\n  assign start_shifting = state == Done;\n\nendmodule\n\n"}
{"task_id": "Prob047_dff8ar", "glodcode": "\nmodule RefModule (\n  input clk,\n  input [7:0] d,\n  input areset,\n  output reg [7:0] q\n);\n\n  always @(posedge clk, posedge areset)\n    if (areset)\n      q <= 0;\n    else\n      q <= d;\n\nendmodule\n\n"}
{"task_id": "Prob048_m2014_q4c", "glodcode": "\nmodule RefModule (\n  input clk,\n  input d,\n  input r,\n  output logic q\n);\n\n  always@(posedge clk) begin\n    if (r)\n      q <= 0;\n    else\n      q <= d;\n  end\n\nendmodule\n\n"}
{"task_id": "Prob007_wire", "glodcode": "\nmodule RefModule (\n  input in,\n  output out\n);\n\n  assign out = in;\n\nendmodule\n\n"}
{"task_id": "Prob066_edgecapture", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  input [31:0] in,\n  output reg [31:0] out\n);\n\n  reg [31:0] d_last;\n\n  always @(posedge clk) begin\n    d_last <= in;\n    if (reset)\n      out <= '0;\n    else\n      out <= out | (~in & d_last);\n  end\n\nendmodule\n\n"}
{"task_id": "Prob025_reduction", "glodcode": "\nmodule RefModule (\n  input [7:0] in,\n  output parity\n);\n\n  assign parity = ^in;\n\nendmodule\n\n"}
{"task_id": "Prob142_lemmings2", "glodcode": "\nmodule RefModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  output walk_left,\n  output walk_right,\n  output aaah\n);\n\n  parameter WL=0, WR=1, FALLL=2, FALLR=3;\n  reg [1:0] state;\n  reg [1:0] next;\n\n  always_comb begin\n    case (state)\n      WL: next = ground ? (bump_left ? WR : WL) : FALLL;\n      WR: next = ground ? (bump_right ? WL: WR) : FALLR;\n      FALLL: next = ground ? WL : FALLL;\n      FALLR: next = ground ? WR : FALLR;\n    endcase\n  end\n\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n      else state <= next;\n  end\n\n  assign walk_left = (state==WL);\n  assign walk_right = (state==WR);\n  assign aaah = (state == FALLL) || (state == FALLR);\n\nendmodule\n\n"}
{"task_id": "Prob031_dff", "glodcode": "\nmodule RefModule (\n  input clk,\n  input d,\n  output reg q\n);\n\n  initial\n    q = 1'hx;\n\n  always @(posedge clk)\n    q <= d;\n\nendmodule\n\n"}
{"task_id": "Prob144_conwaylife", "glodcode": "\nmodule RefModule (\n  input clk,\n  input load,\n  input [255:0] data,\n  output reg [255:0] q\n);\n\n  logic [323:0] q_pad;\n  always@(*) begin\n    for (int i=0;i<16;i++)\n      q_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];\n    q_pad[1 +: 16] = q[16*15 +: 16];\n    q_pad[18*17+1 +: 16] = q[0 +: 16];\n\n    for (int i=0; i<18; i++) begin\n      q_pad[i*18] = q_pad[i*18+16];\n      q_pad[i*18+17] = q_pad[i*18+1];\n    end\n  end\n\n  always @(posedge clk) begin\n    for (int i=0;i<16;i++)\n    for (int j=0;j<16;j++) begin\n      q[i*16+j] <=\n        ((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n        q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n        q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18]) & 3'h7 | q[i*16+j]) == 3'h3;\n    end\n\n    if (load)\n      q <= data;\n\n  end\n\nendmodule\n\n"}
{"task_id": "Prob032_vector0", "glodcode": "\nmodule RefModule (\n  input [2:0] vec,\n  output [2:0] outv,\n  output o2,\n  output o1,\n  output o0\n);\n\n  assign outv = vec;\n  assign {o2, o1, o0} = vec;\n\nendmodule\n\n"}
{"task_id": "Prob084_ece241_2013_q12", "glodcode": "\nmodule RefModule (\n  input clk,\n  input enable,\n  input S,\n  input A,\n  input B,\n  input C,\n  output reg Z\n);\n\n  reg [7:0] q;\n  always @(posedge clk) begin\n    if (enable)\n      q <= {q[6:0], S};\n  end\n\n  assign Z = q[ {A, B, C} ];\n\nendmodule\n\n"}
{"task_id": "Prob122_kmap4", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output reg out\n);\n\n  always @(*) begin\n    case({a,b,c,d})\n      4'h0: out = 0;\n      4'h1: out = 1;\n      4'h3: out = 0;\n      4'h2: out = 1;\n      4'h4: out = 1;\n      4'h5: out = 0;\n      4'h7: out = 1;\n      4'h6: out = 0;\n      4'hc: out = 0;\n      4'hd: out = 1;\n      4'hf: out = 0;\n      4'he: out = 1;\n      4'h8: out = 1;\n      4'h9: out = 0;\n      4'hb: out = 1;\n      4'ha: out = 0;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob129_ece241_2013_q8", "glodcode": "\nmodule RefModule (\n  input clk,\n  input aresetn,\n  input x,\n  output reg z\n);\n\n  parameter S=0, S1=1, S10=2;\n  reg[1:0] state, next;\n\n  always@(posedge clk, negedge aresetn)\n    if (!aresetn)\n      state <= S;\n    else\n      state <= next;\n\n  always_comb begin\n    case (state)\n      S: next = x ? S1 : S;\n      S1: next = x ? S1 : S10;\n      S10: next = x ? S1 : S;\n      default: next = 'x;\n    endcase\n  end\n\n  always_comb begin\n    case (state)\n      S: z = 0;\n      S1: z = 0;\n      S10: z = x;\n      default: z = 'x;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob043_vector5", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  input e,\n  output [24:0] out\n);\n\n  assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\n\nendmodule\n\n"}
{"task_id": "Prob132_always_if2", "glodcode": "\nmodule RefModule (\n  input cpu_overheated,\n  output reg shut_off_computer,\n  input arrived,\n  input gas_tank_empty,\n  output reg keep_driving\n);\n\n  always @(*) begin\n    if (cpu_overheated)\n      shut_off_computer = 1;\n    else\n      shut_off_computer = 0;\n  end\n\n  always @(*) begin\n    if (~arrived)\n      keep_driving = !gas_tank_empty;\n    else\n      keep_driving = 1'b0;\n  end\n\nendmodule\n\n"}
{"task_id": "Prob141_count_clock", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  input ena,\n  output reg pm,\n  output reg [7:0] hh,\n  output reg [7:0] mm,\n  output reg [7:0] ss\n);\n\n  wire [6:0] enable = {\n    {hh[7:0],mm[7:0],ss[7:0]}==24'h115959,\n    {hh[3:0],mm[7:0],ss[7:0]}==20'h95959,\n    {mm[7:0],ss[7:0]}==16'h5959,\n    {mm[3:0],ss[7:0]}==12'h959,\n    ss[7:0]==8'h59,\n    ss[3:0] == 4'h9,\n    1'b1};\n\n  always @(posedge clk)\n    if (reset)\n      {pm,hh,mm,ss} <= 25'h0120000;\n    else if (ena) begin\n      if (enable[0] && ss[3:0] == 9) ss[3:0] <= 0;\n      else if (enable[0]) ss[3:0] <= ss[3:0] + 1;\n\n      if (enable[1] && ss[7:4] == 4'h5) ss[7:4] <= 0;\n      else if (enable[1]) ss[7:4] <= ss[7:4] + 1;\n\n      if (enable[2] && mm[3:0] == 9) mm[3:0] <= 0;\n      else if (enable[2]) mm[3:0] <= mm[3:0] + 1;\n\n      if (enable[3] && mm[7:4] == 4'h5) mm[7:4] <= 0;\n      else if (enable[3]) mm[7:4] <= mm[7:4] + 1;\n\n      if (enable[4] && hh[3:0] == 4'h9) hh[3:0] <= 0;\n      else if (enable[4]) hh[3:0] <= hh[3:0] + 1;\n\n      if (enable[4] && hh[7:0] == 8'h12) hh[7:0] <= 8'h1;\n      else if (enable[5]) hh[7:4] <= hh[7:4] + 1;\n\n      if (enable[6]) pm <= ~pm;\n    end\n\nendmodule\n\n"}
{"task_id": "Prob100_fsm3comb", "glodcode": "\nmodule RefModule (\n  input in,\n  input [1:0] state,\n  output reg [1:0] next_state,\n  output out\n);\n\n  parameter A=0, B=1, C=2, D=3;\n\n  always_comb begin\n    case (state)\n      A: next_state = in ? B : A;\n      B: next_state = in ? B : C;\n      C: next_state = in ? D : A;\n      D: next_state = in ? B : C;\n    endcase\n  end\n\n  assign out = (state==D);\n\nendmodule\n\n"}
{"task_id": "Prob073_dff16e", "glodcode": "\nmodule RefModule (\n  input clk,\n  input resetn,\n  input [1:0] byteena,\n  input [15:0] d,\n  output reg [15:0] q\n);\n\n  always @(posedge clk) begin\n    if (!resetn)\n      q <= 0;\n    else begin\n      if (byteena[0])\n        q[7:0] <= d[7:0];\n      if (byteena[1])\n        q[15:8] <= d[15:8];\n    end\n  end\n\nendmodule\n\n"}
{"task_id": "Prob083_mt2015_q4b", "glodcode": "\nmodule RefModule (\n  input x,\n  input y,\n  output z\n);\n\n  assign z = ~(x^y);\n\nendmodule\n\n"}
{"task_id": "Prob006_vectorr", "glodcode": "\nmodule RefModule (\n  input [7:0] in,\n  output [7:0] out\n);\n\n  assign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in;\n\nendmodule\n\n"}
{"task_id": "Prob143_fsm_onehot", "glodcode": "\nmodule RefModule (\n  input in,\n  input [9:0] state,\n  output [9:0] next_state,\n  output out1,\n  output out2\n);\n\n  assign out1 = state[8] | state[9];\n  assign out2 = state[7] | state[9];\n\n  assign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n  assign next_state[1] = in && (state[0] | state[8] | state[9]);\n  assign next_state[2] = in && state[1];\n  assign next_state[3] = in && state[2];\n  assign next_state[4] = in && state[3];\n  assign next_state[5] = in && state[4];\n  assign next_state[6] = in && state[5];\n  assign next_state[7] = in && (state[6] | state[7]);\n  assign next_state[8] = !in && state[5];\n  assign next_state[9] = !in && state[6];\n\nendmodule\n\n"}
{"task_id": "Prob064_vector3", "glodcode": "\nmodule RefModule (\n  input [4:0] a,\n  input [4:0] b,\n  input [4:0] c,\n  input [4:0] d,\n  input [4:0] e,\n  input [4:0] f,\n  output [7:0] w,\n  output [7:0] x,\n  output [7:0] y,\n  output [7:0] z\n);\n\n  assign { w,x,y,z} = {a,b,c,d,e,f,2'b11};\n\nendmodule\n\n"}
{"task_id": "Prob140_fsm_hdlc", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  input in,\n  output disc,\n  output flag,\n  output err\n);\n\n  parameter [3:0] S0=0, S1=1, S2=2, S3=3, S4=4, S5=5, S6=6, SERR=7, SDISC=8, SFLAG=9;\n  reg [3:0] state, next;\n\n  assign disc = state == SDISC;\n  assign flag = state == SFLAG;\n  assign err = state == SERR;\n\n  always @(posedge clk) begin\n    case (state)\n      S0: state <= in ? S1 : S0;\n      S1: state <= in ? S2 : S0;\n      S2: state <= in ? S3 : S0;\n      S3: state <= in ? S4 : S0;\n      S4: state <= in ? S5 : S0;\n      S5: state <= in ? S6 : SDISC;\n      S6: state <= in ? SERR : SFLAG;\n      SERR: state <= in ? SERR : S0;\n      SFLAG: state <= in ? S1 : S0;\n      SDISC: state <= in ? S1 : S0;\n      default: state <= 'x;\n    endcase\n\n    if (reset) state <= S0;\n  end\n\nendmodule\n\n"}
{"task_id": "Prob082_lfsr32", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  output reg [31:0] q\n);\n\n  logic [31:0] q_next;\n  always@(q) begin\n    q_next = q[31:1];\n    q_next[31] = q[0];\n    q_next[21] ^= q[0];\n    q_next[1] ^= q[0];\n    q_next[0] ^= q[0];\n  end\n\n  always @(posedge clk) begin\n    if (reset)\n      q <= 32'h1;\n    else\n      q <= q_next;\n  end\n\nendmodule\n\n"}
{"task_id": "Prob019_m2014_q4f", "glodcode": "\nmodule RefModule (\n  input in1,\n  input in2,\n  output logic out\n);\n\n  assign out = in1 & ~in2;\n\nendmodule\n\n"}
{"task_id": "Prob069_truthtable1", "glodcode": "\nmodule RefModule (\n  input x3,\n  input x2,\n  input x1,\n  output f\n);\n\n  assign f = ( ~x3 & x2 & ~x1 ) |\n        ( ~x3 & x2 & x1 ) |\n        ( x3 & ~x2 & x1 ) |\n        ( x3 & x2 & x1 ) ;\n\nendmodule\n\n"}
{"task_id": "Prob094_gatesv", "glodcode": "\nmodule RefModule (\n  input [3:0] in,\n  output [2:0] out_both,\n  output [3:1] out_any,\n  output [3:0] out_different\n);\n\n  assign out_both = in[2:0] & in[3:1];\n  assign out_any = in[2:0] | in[3:1];\n  assign out_different = in^{in[0], in[3:1]};\n\nendmodule\n\n"}
{"task_id": "Prob042_vector4", "glodcode": "\nmodule RefModule (\n  input [7:0] in,\n  output [31:0] out\n);\n\n  assign out = { {24{in[7]}}, in };\n\nendmodule\n\n"}
{"task_id": "Prob145_circuit8", "glodcode": "\nmodule RefModule (\n  input clock,\n  input a,\n  output reg p,\n  output reg q\n);\n\n  always @(negedge clock)\n    q <= a;\n\n  always @(*)\n    if (clock)\n      p = a;\n\nendmodule\n\n"}
{"task_id": "Prob028_m2014_q4a", "glodcode": "\nmodule RefModule (\n  input d,\n  input ena,\n  output logic q\n);\n\n  always@(*) begin\n    if (ena)\n      q = d;\n  end\n\nendmodule\n\n"}
{"task_id": "Prob101_circuit4", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n\n  assign q = c | b;\n\nendmodule\n\n"}
{"task_id": "Prob072_thermostat", "glodcode": "\nmodule RefModule (\n  input mode,\n  input too_cold,\n  input too_hot,\n  input fan_on,\n  output heater,\n  output aircon,\n  output fan\n);\n\n  assign fan = (mode ? too_cold : too_hot) | fan_on;\n  assign heater = (mode & too_cold);\n  assign aircon = (~mode & too_hot);\n\nendmodule\n\n"}
{"task_id": "Prob110_fsm2", "glodcode": "\nmodule RefModule (\n  input clk,\n  input j,\n  input k,\n  input areset,\n  output out\n);\n\n  parameter A=0, B=1;\n  reg state;\n  reg next;\n\n    always_comb begin\n    case (state)\n      A: next = j ? B : A;\n      B: next = k ? A : B;\n    endcase\n    end\n\n    always @(posedge clk, posedge areset) begin\n    if (areset) state <= A;\n        else state <= next;\n  end\n\n  assign out = (state==B);\n\nendmodule\n\n"}
{"task_id": "Prob041_dff8r", "glodcode": "\nmodule RefModule (\n  input clk,\n  input [7:0] d,\n  input reset,\n  output reg [7:0] q\n);\n\n  always @(posedge clk)\n    if (reset)\n      q <= 0;\n    else\n      q <= d;\n\nendmodule\n\n"}
{"task_id": "Prob061_2014_q4a", "glodcode": "\nmodule RefModule (\n  input clk,\n  input w,\n  input R,\n  input E,\n  input L,\n  output reg Q\n);\n\n  always @(posedge clk)\n    if (L)\n      Q <= R;\n    else if (E)\n      Q <= w;\n\nendmodule\n\n"}
{"task_id": "Prob002_m2014_q4i", "glodcode": "\nmodule RefModule (\n  output out\n);\n\n  assign out = 1'b0;\n\nendmodule\n\n"}
{"task_id": "Prob112_always_case2", "glodcode": "\nmodule RefModule (\n  input [3:0] in,\n  output reg [1:0] pos\n);\n\n  always @(*) begin\n    case (in)\n      4'h0: pos = 2'h0;\n      4'h1: pos = 2'h0;\n      4'h2: pos = 2'h1;\n      4'h3: pos = 2'h0;\n      4'h4: pos = 2'h2;\n      4'h5: pos = 2'h0;\n      4'h6: pos = 2'h1;\n      4'h7: pos = 2'h0;\n      4'h8: pos = 2'h3;\n      4'h9: pos = 2'h0;\n      4'ha: pos = 2'h1;\n      4'hb: pos = 2'h0;\n      4'hc: pos = 2'h2;\n      4'hd: pos = 2'h0;\n      4'he: pos = 2'h1;\n      4'hf: pos = 2'h0;\n      default: pos = 2'b0;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob090_circuit1", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  output q\n);\n\n  assign q = a&b;\n\nendmodule\n\n"}
{"task_id": "Prob136_m2014_q6", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  input w,\n  output z\n);\n\n  parameter A=0, B=1, C=2, D=3, E=4, F=5;\n  reg [2:0] state, next;\n\n  always @(posedge clk)\n    if (reset)\n      state <= A;\n    else\n      state <= next;\n\n  always_comb begin\n    case(state)\n      A: next = w ? A : B;\n      B: next = w ? D : C;\n      C: next = w ? D : E;\n      D: next = w ? A : F;\n      E: next = w ? D : E;\n      F: next = w ? D : C;\n      default: next = 'x;\n    endcase\n  end\n\n  assign z = (state == E || state == F);\n\nendmodule\n\n"}
{"task_id": "Prob034_dff8", "glodcode": "\nmodule RefModule (\n  input clk,\n  input [7:0] d,\n  output reg [7:0] q\n);\n\n  initial\n    q = 8'h0;\n\n  always @(posedge clk)\n    q <= d;\n\nendmodule\n\n"}
{"task_id": "Prob058_alwaysblock2", "glodcode": "\nmodule RefModule (\n  input clk,\n  input a,\n  input b,\n  output out_assign,\n  output reg out_always_comb,\n  output reg out_always_ff\n);\n\n  assign out_assign = a ^ b;\n  always @(*) out_always_comb = a ^ b;\n  always @(posedge clk) out_always_ff <= a ^ b;\n\nendmodule\n\n"}
{"task_id": "Prob054_edgedetect", "glodcode": "\nmodule RefModule (\n  input clk,\n  input [7:0] in,\n  output reg [7:0] pedge\n);\n\n  reg [7:0] d_last;\n\n  always @(posedge clk) begin\n    d_last <= in;\n    pedge <= in & ~d_last;\n  end\n\nendmodule\n\n"}
{"task_id": "Prob029_m2014_q4g", "glodcode": "\nmodule RefModule (\n  input in1,\n  input in2,\n  input in3,\n  output logic out\n);\n\n  assign out = (~(in1 ^ in2)) ^ in3;\n\nendmodule\n\n"}
{"task_id": "Prob137_fsm_serial", "glodcode": "\nmodule RefModule (\n  input clk,\n  input in,\n  input reset,\n  output done\n);\n\n  parameter B0=0, B1=1, B2=2, B3=3, B4=4, B5=5, B6=6, B7=7, START=8, STOP=9, DONE=10, ERR=11;\n  reg [3:0] state;\n  reg [3:0] next;\n\n  always_comb begin\n    case (state)\n      START: next = in ? START : B0;  // start bit is 0\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = B4;\n      B4: next = B5;\n      B5: next = B6;\n      B6: next = B7;\n      B7: next = STOP;\n      STOP: next = in ? DONE : ERR;  // stop bit is 1. Idle state is 1.\n      DONE: next = in ? START : B0;\n      ERR: next = in ? START : ERR;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= START;\n      else state <= next;\n  end\n\n  assign done = (state==DONE);\n\nendmodule\n\n"}
{"task_id": "Prob121_2014_q3bfsm", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  input x,\n  output reg z\n);\n\n  parameter A=0, B=1, C=2, D=3, E=4;\n  reg [2:0] state, next;\n\n  always @(posedge clk) begin\n    if (reset) state <= A;\n    else state <= next;\n  end\n\n  always_comb begin\n    case (state)\n      A: next = x ? B : A;\n      B: next = x ? E : B;\n      C: next = x ? B : C;\n      D: next = x ? C : B;\n      E: next = x ? E : D;\n      default: next = 'x;\n    endcase\n  end\n\n  assign z = (state == D) || (state == E);\n\nendmodule\n\n"}
{"task_id": "Prob156_review2015_fancytimer", "glodcode": "\nmodule RefModule (\n  input wire clk,\n  input wire reset,\n  input wire data,\n  output wire [3:0] count,\n  output reg counting,\n  output reg done,\n  input wire ack\n);\n\n  typedef enum logic[3:0] {\n    S, S1, S11, S110, B0, B1, B2, B3, Count, Wait\n  } States;\n\n  States state, next;\n\n  reg shift_ena;\n  reg [9:0] fcount;\n  reg [3:0] scount;\n  wire done_counting = (scount == 0) && (fcount == 999);\n\n  always_comb begin\n    case (state)\n      S: next = States'(data ? S1: S);\n      S1: next = States'(data ? S11: S);\n      S11: next = States'(data ? S11 : S110);\n      S110: next = States'(data ? B0 : S);\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = Count;\n      Count: next = States'(done_counting ? Wait : Count);\n      Wait: next = States'(ack ? S : Wait);\n      default: next = States'(4'bx);\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= S;\n    else state <= next;\n  end\n\n  always_comb begin\n    shift_ena = 0; counting = 0; done = 0;\n    if (state == B0 || state == B1 || state == B2 || state == B3)\n      shift_ena = 1;\n    if (state == Count)\n      counting = 1;\n    if (state == Wait)\n      done = 1;\n\n    if (|state === 1'bx) begin\n      {shift_ena, counting, done} = 'x;\n    end\n  end\n\n  // Shift register\n  always @(posedge clk) begin\n    if (shift_ena)\n      scount <= {scount[2:0], data};\n    else if (counting && fcount == 999)\n      scount <= scount - 1'b1;\n  end\n\n  // Fast counter\n  always @(posedge clk)\n    if (!counting)\n      fcount <= 10'h0;\n    else if (fcount == 999)\n      fcount <= 10'h0;\n    else\n      fcount <= fcount + 1'b1;\n\n  assign count = counting ? scount : 'x;\n\nendmodule\n\n"}
{"task_id": "Prob067_countslow", "glodcode": "\nmodule RefModule (\n  input clk,\n  input slowena,\n  input reset,\n  output reg [3:0] q\n);\n\n  always @(posedge clk)\n    if (reset)\n      q <= 0;\n    else if (slowena) begin\n      if (q == 9)\n        q <= 0;\n      else\n        q <= q+1;\n    end\n\nendmodule\n\n"}
{"task_id": "Prob078_dualedge", "glodcode": "\nmodule RefModule (\n  input clk,\n  input d,\n  output reg q\n);\n\n  /*always @(posedge clk, negedge clk) begin\n    q <= d;\n  end*/\n\n  reg qp, qn;\n  always @(posedge clk)\n    qp <= d;\n  always @(negedge clk)\n    qn <= d;\n\n  // This causes q to change too early when clk changes. Need delay by\n  // delta cycle\n  // assign q = clk ? qp : qn;\n  always @(*)\n    q <= clk ? qp : qn;\n\nendmodule\n\n"}
{"task_id": "Prob003_step_one", "glodcode": "\nmodule RefModule (\n  output one\n);\n\n  assign one = 1'b1;\n\nendmodule\n\n"}
{"task_id": "Prob146_fsm_serialdata", "glodcode": "\nmodule RefModule (\n  input clk,\n  input in,\n  input reset,\n  output [7:0] out_byte,\n  output done\n);\n\n  parameter B0=0, B1=1, B2=2, B3=3, B4=4, B5=5, B6=6, B7=7, START=8, STOP=9, DONE=10, ERR=11;\n  reg [3:0] state;\n  reg [3:0] next;\n\n  reg [9:0] byte_r;\n\n  always_comb begin\n    case (state)\n      START: next = in ? START : B0;  // start bit is 0\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = B4;\n      B4: next = B5;\n      B5: next = B6;\n      B6: next = B7;\n      B7: next = STOP;\n      STOP: next = in ? DONE : ERR;  // stop bit is 1. Idle state is 1.\n      DONE: next = in ? START : B0;\n      ERR: next = in ? START : ERR;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= START;\n      else state <= next;\n  end\n\n  always @(posedge clk) begin\n    byte_r <= {in, byte_r[9:1]};\n  end\n\n  assign done = (state==DONE);\n  assign out_byte = done ? byte_r[8:1] : 8'hx;\n\nendmodule\n\n"}
{"task_id": "Prob055_conditional", "glodcode": "\nmodule RefModule (\n  input [7:0] a,\n  input [7:0] b,\n  input [7:0] c,\n  input [7:0] d,\n  output reg [7:0] min\n);\n\n  always_comb begin\n    min = a;\n    if (min > b) min = b;\n    if (min > c) min = c;\n    if (min > d) min = d;\n  end\n\nendmodule\n\n"}
{"task_id": "Prob045_edgedetect2", "glodcode": "\nmodule RefModule (\n  input clk,\n  input [7:0] in,\n  output reg [7:0] anyedge\n);\n\n  reg [7:0] d_last;\n\n  always @(posedge clk) begin\n    d_last <= in;\n    anyedge <= in ^ d_last;\n  end\n\nendmodule\n\n"}
{"task_id": "Prob085_shift4", "glodcode": "\nmodule RefModule (\n  input clk,\n  input areset,\n  input load,\n  input ena,\n  input [3:0] data,\n  output reg [3:0] q\n);\n\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      q <= 0;\n    else if (load)\n      q <= data;\n    else if (ena)\n      q <= q[3:1];\n  end\n\nendmodule\n\n"}
{"task_id": "Prob015_vector1", "glodcode": "\nmodule RefModule (\n  input [15:0] in,\n  output [7:0] out_hi,\n  output [7:0] out_lo\n);\n\n  assign {out_hi, out_lo} = in;\n\nendmodule\n\n"}
{"task_id": "Prob114_bugs_case", "glodcode": "\nmodule RefModule (\n  input [7:0] code,\n  output reg [3:0] out,\n  output reg valid\n);\n\n  // uhh.. make a case statement: maps scancode to 0-9, but accidentally\n  // infer a latch? and have one of the entries be wrong? (duplicate\n  // case, using different base!)\n\n  always @(*) begin\n    out = 0;\n    valid = 1;\n    case (code)\n      8'h45: out = 0;\n      8'h16: out = 1;\n      8'h1e: out = 2;\n      8'h26: out = 3;\n      8'h25: out = 4;\n      8'h2e: out = 5;\n      8'h36: out = 6;\n      8'h3d: out = 7;\n      8'h3e: out = 8;\n      8'h46: out = 9;\n      default: valid = 0;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob005_notgate", "glodcode": "\nmodule RefModule (\n  input in,\n  output out\n);\n\n  assign out = ~in;\n\nendmodule\n\n"}
{"task_id": "Prob030_popcount255", "glodcode": "\nmodule RefModule (\n  input [254:0] in,\n  output reg [7:0] out\n);\n\n  always_comb  begin\n    out = 0;\n    for (int i=0;i<255;i++)\n      out = out + in[i];\n  end\n\nendmodule\n\n"}
{"task_id": "Prob148_2013_q2afsm", "glodcode": "\nmodule RefModule (\n  input clk,\n  input resetn,\n  input [3:1] r,\n  output [3:1] g\n);\n\n  parameter A=0, B=1, C=2, D=3;\n  reg [1:0] state, next;\n\n  always @(posedge clk) begin\n    if (~resetn) state <= A;\n    else state <= next;\n  end\n\n  always@(state,r) begin\n    case (state)\n      A: if (r[1]) next = B;\n         else if (r[2]) next = C;\n         else if (r[3]) next = D;\n         else next = A;\n      B: next = r[1] ? B : A;\n      C: next = r[2] ? C : A;\n      D: next = r[3] ? D : A;\n      default: next = 'x;\n    endcase\n  end\n\n  assign g[1] = (state == B);\n  assign g[2] = (state == C);\n  assign g[3] = (state == D);\n\nendmodule\n\n"}
{"task_id": "Prob011_norgate", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  output out\n);\n\n  assign out = ~(a | b);\n\nendmodule\n\n"}
{"task_id": "Prob092_gatesv100", "glodcode": "\nmodule RefModule (\n  input [99:0] in,\n  output [98:0] out_both,\n  output [99:1] out_any,\n  output [99:0] out_different\n);\n\n  assign out_both = in & in[99:1];\n  assign out_any = in | in[99:1];\n  assign out_different = in^{in[0], in[99:1]};\n\nendmodule\n\n"}
{"task_id": "Prob037_review2015_count1k", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  output reg [9:0] q\n);\n\n  always @(posedge clk)\n    if (reset || q == 999)\n      q <= 0;\n    else\n      q <= q+1;\n\nendmodule\n\n"}
{"task_id": "Prob093_ece241_2014_q3", "glodcode": "\nmodule RefModule (\n  input c,\n  input d,\n  output [3:0] mux_in\n);\n\n  assign mux_in[0] = c | d;\n  assign mux_in[1] = 0;\n  assign mux_in[2] = ~d;\n  assign mux_in[3] = c&d;\n\nendmodule\n\n"}
{"task_id": "Prob128_fsm_ps2", "glodcode": "\nmodule RefModule (\n  input clk,\n  input [7:0] in,\n  input reset,\n  output done\n);\n\n  parameter BYTE1=0, BYTE2=1, BYTE3=2, DONE=3;\n  reg [1:0] state;\n  reg [1:0] next;\n\n  wire in3 = in[3];\n\n  always_comb begin\n    case (state)\n      BYTE1: next = in3 ? BYTE2 : BYTE1;\n      BYTE2: next = BYTE3;\n      BYTE3: next = DONE;\n      DONE: next = in3 ? BYTE2 : BYTE1;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= BYTE1;\n      else state <= next;\n  end\n\n  assign done = (state==DONE);\n\nendmodule\n\n"}
{"task_id": "Prob050_kmap1", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input c,\n  output out\n);\n\n  assign out = (a | b | c);\n\nendmodule\n\n"}
{"task_id": "Prob155_lemmings4", "glodcode": "\nmodule RefModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  input dig,\n  output walk_left,\n  output walk_right,\n  output aaah,\n  output digging\n);\n\n  parameter WL=0, WR=1, FALLL=2, FALLR=3, DIGL=4, DIGR=5, DEAD=6;\n  reg [2:0] state;\n  reg [2:0] next;\n\n  reg [4:0] fall_counter;\n\n  always_comb begin\n    case (state)\n      WL: if (!ground) next = FALLL;\n        else if (dig) next = DIGL;\n        else if (bump_left) next = WR;\n        else next = WL;\n      WR:\n        if (!ground) next = FALLR;\n        else if (dig) next = DIGR;\n        else if (bump_right) next = WL;\n        else next = WR;\n      FALLL: next = ground ? (fall_counter >= 20 ? DEAD : WL) : FALLL;\n      FALLR: next = ground ? (fall_counter >= 20 ? DEAD : WR) : FALLR;\n      DIGL: next = ground ? DIGL : FALLL;\n      DIGR: next = ground ? DIGR : FALLR;\n      DEAD: next = DEAD;\n    endcase\n  end\n\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n      else state <= next;\n  end\n\n  always @(posedge clk) begin\n    if (state == FALLL || state == FALLR) begin\n      if (fall_counter < 20)\n        fall_counter <= fall_counter + 1'b1;\n    end\n    else\n      fall_counter <= 0;\n  end\n\n  assign walk_left = (state==WL);\n  assign walk_right = (state==WR);\n  assign aaah = (state == FALLL) || (state == FALLR);\n  assign digging = (state == DIGL) || (state == DIGR);\n\nendmodule\n\n"}
{"task_id": "Prob014_andgate", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  output out\n);\n\n  assign out = a & b;\n\nendmodule\n\n"}
{"task_id": "Prob049_m2014_q4b", "glodcode": "\nmodule RefModule (\n  input clk,\n  input d,\n  input ar,\n  output logic q\n);\n\n  always@(posedge clk or posedge ar) begin\n    if (ar)\n      q <= 0;\n    else\n      q <= d;\n  end\n\nendmodule\n\n"}
{"task_id": "Prob105_rotate100", "glodcode": "\nmodule RefModule (\n  input clk,\n  input load,\n  input [1:0] ena,\n  input [99:0] data,\n  output reg [99:0] q\n);\n\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else if (ena == 2'h1)\n      q <= {q[0], q[99:1]};\n    else if (ena == 2'h2)\n      q <= {q[98:0], q[99]};\n  end\n\nendmodule\n\n"}
{"task_id": "Prob086_lfsr5", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  output reg [4:0] q\n);\n\n  logic [4:0] q_next;\n  always @(q) begin\n    q_next = q[4:1];\n    q_next[4] = q[0];\n    q_next[2] ^= q[0];\n  end\n\n  always @(posedge clk) begin\n    if (reset)\n      q <= 5'h1;\n    else\n      q <= q_next;\n  end\n\nendmodule\n\n"}
{"task_id": "Prob026_alwaysblock1", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  output out_assign,\n  output reg out_alwaysblock\n);\n\n  assign out_assign = a & b;\n  always @(*) out_alwaysblock = a & b;\n\nendmodule\n\n"}
{"task_id": "Prob060_m2014_q4k", "glodcode": "\nmodule RefModule (\n  input clk,\n  input resetn,\n  input in,\n  output out\n);\n\n  reg [3:0] sr;\n  always @(posedge clk) begin\n    if (~resetn)\n      sr <= '0;\n    else\n      sr <= {sr[2:0], in};\n  end\n\n  assign out = sr[3];\n\nendmodule\n\n"}
{"task_id": "Prob124_rule110", "glodcode": "\nmodule RefModule (\n  input clk,\n  input load,\n  input [511:0] data,\n  output reg [511:0] q\n);\n\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else begin\n      q <=\n      ~((q[$bits(q)-1:1] & q[$bits(q)-1:0] & {q[$bits(q)-2:0], 1'b0}) |\n      (~q[$bits(q)-1:1] & ~q[$bits(q)-1:0] & ~{q[$bits(q)-2:0], 1'b0}) |\n      (q[$bits(q)-1:1] & ~q[$bits(q)-1:0] & ~{q[$bits(q)-2:0], 1'b0}) )\n      ;\n    end\n  end\n\nendmodule\n\n"}
{"task_id": "Prob118_history_shift", "glodcode": "\nmodule RefModule (\n  input clk,\n  input areset,\n  input predict_valid,\n  input predict_taken,\n  output logic [31:0] predict_history,\n\n  input train_mispredicted,\n  input train_taken,\n  input [31:0] train_history\n);\n\n  always@(posedge clk, posedge areset)\n    if (areset) begin\n      predict_history = 0;\n        end  else begin\n      if (train_mispredicted)\n        predict_history <= {train_history, train_taken};\n      else if (predict_valid)\n        predict_history <= {predict_history, predict_taken};\n    end\n\nendmodule\n\n"}
{"task_id": "Prob053_m2014_q4d", "glodcode": "\nmodule RefModule (\n  input clk,\n  input in,\n  output logic out\n);\n\n  initial\n    out = 0;\n\n  always@(posedge clk) begin\n    out <= in ^ out;\n  end\n\nendmodule\n\n"}
{"task_id": "Prob123_bugs_addsubz", "glodcode": "\nmodule RefModule (\n  input do_sub,\n  input [7:0] a,\n  input [7:0] b,\n  output reg [7:0] out,\n  output reg result_is_zero\n);\n\n  always @(*) begin\n    case (do_sub)\n      0: out = a + b;\n      1: out = a - b;\n    endcase\n    result_is_zero = (out == 0);\n  end\n\nendmodule\n\n"}
{"task_id": "Prob134_2014_q3c", "glodcode": "\nmodule RefModule (\n  input clk,\n  input x,\n  input [2:0] y,\n  output reg Y0,\n  output reg z\n);\n\n  always_comb begin\n    case ({y[2:0], x})\n      4'h0: Y0 = 0;\n      4'h1: Y0 = 1;\n      4'h2: Y0 = 1;\n      4'h3: Y0 = 0;\n      4'h4: Y0 = 0;\n      4'h5: Y0 = 1;\n      4'h6: Y0 = 1;\n      4'h7: Y0 = 0;\n      4'h8: Y0 = 1;\n      4'h9: Y0 = 0;\n      default: Y0 = 1'bx;\n    endcase\n\n    case (y[2:0])\n      3'h0: z = 0;\n      3'h1: z = 0;\n      3'h2: z = 0;\n      3'h3: z = 1;\n      3'h4: z = 1;\n      default: z = 1'bx;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob095_review2015_fsmshift", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  output shift_ena\n);\n\n  parameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\n  reg [2:0] state, next;\n\n  always_comb begin\n    case (state)\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = Done;\n      Done: next = Done;\n    endcase\n  end\n\n  always @(posedge clk)\n    if (reset) state <= B0;\n    else state <= next;\n\n  assign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\nendmodule\n\n"}
{"task_id": "Prob108_rule90", "glodcode": "\nmodule RefModule (\n  input clk,\n  input load,\n  input [511:0] data,\n  output reg [511:0] q\n);\n\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else begin\n      q <= q[$bits(q)-1:1] ^ {q[$bits(q)-2:0], 1'b0} ;\n    end\n  end\n\nendmodule\n\n"}
{"task_id": "Prob127_lemmings1", "glodcode": "\nmodule RefModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  output walk_left,\n  output walk_right\n);\n\n  parameter WL=0, WR=1;\n  reg state;\n  reg next;\n\n  always_comb begin\n    case (state)\n      WL: next = bump_left ? WR : WL;\n      WR: next = bump_right ? WL: WR;\n    endcase\n  end\n\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n      else state <= next;\n  end\n\n  assign walk_left = (state==WL);\n  assign walk_right = (state==WR);\n\nendmodule\n\n"}
{"task_id": "Prob046_dff8p", "glodcode": "\nmodule RefModule (\n  input clk,\n  input [7:0] d,\n  input reset,\n  output reg [7:0] q\n);\n\n  always @(negedge clk)\n    if (reset)\n      q <= 8'h34;\n    else\n      q <= d;\n\nendmodule\n\n"}
{"task_id": "Prob102_circuit3", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n\n  assign q = (a|b) & (c|d);\n\nendmodule\n\n"}
{"task_id": "Prob089_ece241_2014_q5a", "glodcode": "\nmodule RefModule (\n  input clk,\n  input areset,\n  input x,\n  output z\n);\n\n  parameter A=0,B=1,C=2;\n  reg [1:0] state;\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= A;\n    else begin\n      case (state)\n        A: state <= x ? C : A;\n        B: state <= x ? B : C;\n        C: state <= x ? B : C;\n      endcase\n    end\n  end\n\n  assign z = (state == C);\n\nendmodule\n\n"}
{"task_id": "Prob063_review2015_shiftcount", "glodcode": "\nmodule RefModule (\n  input clk,\n  input shift_ena,\n  input count_ena,\n  input data,\n  output reg [3:0] q\n);\n\n  always @(posedge clk) begin\n    if (shift_ena)\n      q <= { q[2:0], data };\n    else if (count_ena)\n      q <= q - 1'b1;\n  end\n\nendmodule\n\n"}
{"task_id": "Prob097_mux9to1v", "glodcode": "\nmodule RefModule (\n  input [15:0] a,\n  input [15:0] b,\n  input [15:0] c,\n  input [15:0] d,\n  input [15:0] e,\n  input [15:0] f,\n  input [15:0] g,\n  input [15:0] h,\n  input [15:0] i,\n  input [3:0] sel,\n  output logic [15:0] out\n);\n\n  always @(*) begin\n    out = '1;\n    case (sel)\n      4'h0: out = a;\n      4'h1: out = b;\n      4'h2: out = c;\n      4'h3: out = d;\n      4'h4: out = e;\n      4'h5: out = f;\n      4'h6: out = g;\n      4'h7: out = h;\n      4'h8: out = i;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob077_wire_decl", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out,\n  output out_n\n);\n\n  wire w1, w2;\n  assign w1 = a&b;\n  assign w2 = c&d;\n  assign out = w1|w2;\n  assign out_n = ~out;\n\nendmodule\n\n"}
{"task_id": "Prob023_vector100r", "glodcode": "\nmodule RefModule (\n  input [99:0] in,\n  output reg [99:0] out\n);\n\n  always_comb\n    for (int i=0;i<$bits(out);i++)\n      out[i] = in[$bits(out)-i-1];\n\nendmodule\n\n"}
{"task_id": "Prob057_kmap2", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out\n);\n\n  assign out = (~c & ~b) | (~d&~a) | (a&c&d) | (b&c&d);\n\nendmodule\n\n"}
{"task_id": "Prob117_circuit9", "glodcode": "\nmodule RefModule (\n  input clk,\n  input a,\n  output reg [2:0] q\n);\n\n  always @(posedge clk)\n    if (a)\n      q <= 4;\n    else if (q == 6)\n      q <= 0;\n    else\n      q <= q + 1'b1;\n\nendmodule\n\n"}
{"task_id": "Prob074_ece241_2014_q4", "glodcode": "\nmodule RefModule (\n  input clk,\n  input x,\n  output z\n);\n\n  reg [2:0] s = 0;\n\n  always @(posedge clk) begin\n    s <= { s[2] ^ x, ~s[1] & x, ~s[0] | x };\n  end\n\n  assign z = ~|s;\n\nendmodule\n\n"}
{"task_id": "Prob088_ece241_2014_q5b", "glodcode": "\nmodule RefModule (\n  input clk,\n  input areset,\n  input x,\n  output z\n);\n\n  parameter A=0,B=1;\n  reg state;\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= A;\n    else begin\n      case (state)\n        A: state <= x ? B : A;\n        B: state <= B;\n      endcase\n    end\n  end\n\n  assign z = (state == A && x==1) | (state == B && x==0);\n\nendmodule\n\n"}
{"task_id": "Prob036_ringer", "glodcode": "\nmodule RefModule (\n  input ring,\n  input vibrate_mode,\n  output ringer,\n  output motor\n);\n\n  assign ringer = ring & ~vibrate_mode;\n  assign motor = ring & vibrate_mode;\n\nendmodule\n\n"}
{"task_id": "Prob008_m2014_q4h", "glodcode": "\nmodule RefModule (\n  input in,\n  output out\n);\n\n  assign out = in;\n\nendmodule\n\n"}
{"task_id": "Prob133_2014_q3fsm", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  input s,\n  input w,\n  output reg z\n);\n\n  parameter A=0, B=1, C=2, S10=3, S11=4, S20=5, S21=6, S22=7;\n  reg [2:0] state, next;\n\n  always @(posedge clk) begin\n    if (reset) state <= A;\n    else state <= next;\n  end\n\n  always_comb begin\n    case (state)\n      A: next = s ? B : A;\n      B: next = w ? S11 : S10;\n      C: next = w ? S11 : S10;\n      S10: next = w ? S21 : S20;\n      S11: next = w ? S22 : S21;\n      S20: next = B;\n      S21: next = w ? C : B;\n      S22: next = w ? B : C;\n      default: next = 'x;\n    endcase\n  end\n\n  assign z = (state == C);\n\nendmodule\n\n"}
{"task_id": "Prob098_circuit7", "glodcode": "\nmodule RefModule (\n  input clk,\n  input a,\n  output reg q\n);\n\n  always @(posedge clk)\n    q <= ~a;\n\nendmodule\n\n"}
{"task_id": "Prob013_m2014_q4e", "glodcode": "\nmodule RefModule (\n  input in1,\n  input in2,\n  output logic out\n);\n\n  assign out = ~(in1 | in2);\n\nendmodule\n\n"}
{"task_id": "Prob152_lemmings3", "glodcode": "\nmodule RefModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  input dig,\n  output walk_left,\n  output walk_right,\n  output aaah,\n  output digging\n);\n\n  parameter WL=0, WR=1, FALLL=2, FALLR=3, DIGL=4, DIGR=5;\n  reg [2:0] state;\n  reg [2:0] next;\n\n  always_comb begin\n    case (state)\n      WL: if (!ground) next = FALLL;\n        else if (dig) next = DIGL;\n        else if (bump_left) next = WR;\n        else next = WL;\n      WR:\n        if (!ground) next = FALLR;\n        else if (dig) next = DIGR;\n        else if (bump_right) next = WL;\n        else next = WR;\n      FALLL: next = ground ? WL : FALLL;\n      FALLR: next = ground ? WR : FALLR;\n      DIGL: next = ground ? DIGL : FALLL;\n      DIGR: next = ground ? DIGR : FALLR;\n    endcase\n  end\n\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n      else state <= next;\n  end\n\n  assign walk_left = (state==WL);\n  assign walk_right = (state==WR);\n  assign aaah = (state == FALLL) || (state == FALLR);\n  assign digging = (state == DIGL) || (state == DIGR);\n\nendmodule\n\n"}
{"task_id": "Prob010_mt2015_q4a", "glodcode": "\nmodule RefModule (\n  input x,\n  input y,\n  output z\n);\n\n  assign z = (x^y) & x;\n\nendmodule\n\n"}
{"task_id": "Prob150_review2015_fsmonehot", "glodcode": "\nmodule RefModule (\n  input d,\n  input done_counting,\n  input ack,\n  input [9:0] state, // 10-bit one-hot current state\n  output B3_next,\n  output S_next,\n  output S1_next,\n  output Count_next,\n  output Wait_next,\n  output done,\n  output counting,\n  output shift_ena\n);\n\n  parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n  assign B3_next = state[B2];\n  assign S_next = state[S]&~d | state[S1]&~d | state[S110]&~d | state[Wait]&ack;\n  assign S1_next = state[S]&d;\n  assign Count_next = state[B3] | state[Count]&~done_counting;\n  assign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n  assign done = state[Wait];\n  assign counting = state[Count];\n  assign shift_ena = |state[B3:B0];\n\nendmodule\n\n"}
{"task_id": "Prob052_gates100", "glodcode": "\nmodule RefModule (\n  input [99:0] in,\n  output out_and,\n  output out_or,\n  output out_xor\n);\n\n  assign out_and = &in;\n  assign out_or = |in;\n  assign out_xor = ^in;\n\nendmodule\n\n"}
{"task_id": "Prob059_wire4", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input c,\n  output w,\n  output x,\n  output y,\n  output z\n);\n\n  assign {w,x,y,z} = {a,b,b,c};\n\nendmodule\n\n"}
{"task_id": "Prob116_m2014_q3", "glodcode": "\nmodule RefModule (\n  input [4:1] x,\n  output logic f\n);\n\n  always_comb begin\n    case (x)\n      4'h0: f = 1'bx;\n      4'h1: f = 1'bx;\n      4'h2: f = 0;\n      4'h3: f = 1'bx;\n      4'h4: f = 1;\n      4'h5: f = 1'bx;\n      4'h6: f = 1;\n      4'h7: f = 0;\n      4'h8: f = 0;\n      4'h9: f = 0;\n      4'ha: f = 1'bx;\n      4'hb: f = 1;\n      4'hc: f = 1;\n      4'hd: f = 1'bx;\n      4'he: f = 1;\n      4'hf: f = 1'bx;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob079_fsm3onehot", "glodcode": "\nmodule RefModule (\n  input in,\n  input [3:0] state,\n  output reg [3:0] next_state,\n  output out\n);\n\n  parameter A=0, B=1, C=2, D=3;\n\n  assign next_state[A] = (state[A] | state[C]) & ~in;\n  assign next_state[B] = (state[A] | state[B] | state[D]) & in;\n  assign next_state[C] = (state[B] | state[D]) & ~in;\n  assign next_state[D] = state[C] & in;\n\n  assign out = (state[D]);\n\nendmodule\n\n"}
{"task_id": "Prob004_vector2", "glodcode": "\nmodule RefModule (\n  input [31:0] in,\n  output [31:0] out\n);\n\n  assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n\n"}
{"task_id": "Prob138_2012_q2fsm", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  input w,\n  output z\n);\n\n  parameter A=0,B=1,C=2,D=3,E=4,F=5;\n  reg[2:0] state, next;\n\n  always @(posedge clk)\n    if (reset) state <= A;\n    else state <= next;\n\n  always_comb begin\n    case (state)\n      A: next = w ? B : A;\n      B: next = w ? C : D;\n      C: next = w ? E : D;\n      D: next = w ? F : A;\n      E: next = w ? E : D;\n      F: next = w ? C : D;\n      default: next = 'x;\n    endcase\n  end\n\n  assign z = (state == E) || (state == F);\n\nendmodule\n\n"}
{"task_id": "Prob071_always_casez", "glodcode": "\nmodule RefModule (\n  input [7:0] in,\n  output reg [2:0] pos\n);\n\n  always @(*) begin\n    casez (in)\n      default : pos = 2'h0;\n      8'bzzzzzzz1: pos = 3'h0;\n      8'bzzzzzz1z: pos = 3'h1;\n      8'bzzzzz1zz: pos = 3'h2;\n      8'bzzzz1zzz: pos = 3'h3;\n      8'bzzz1zzzz: pos = 3'h4;\n      8'bzz1zzzzz: pos = 3'h5;\n      8'bz1zzzzzz: pos = 3'h6;\n      8'b1zzzzzzz: pos = 3'h7;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob091_2012_q2b", "glodcode": "\nmodule RefModule (\n  input [5:0] y,\n  input w,\n  output Y1,\n  output Y3\n);\n\n  assign Y1 = y[0]&w;\n  assign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w;\n\nendmodule\n\n"}
{"task_id": "Prob020_mt2015_eq2", "glodcode": "\nmodule RefModule (\n  input [1:0] A,\n  input [1:0] B,\n  output z\n);\n\n  assign z = A[1:0]==B[1:0];\n\nendmodule\n\n"}
{"task_id": "Prob147_circuit10", "glodcode": "\nmodule RefModule (\n  input clk,\n  input a,\n  input b,\n  output q,\n  output state\n);\n\n  reg c;\n  always @(posedge clk)\n    c <= a&b | a&c | b&c;\n\n  assign q = a^b^c;\n  assign state = c;\n\nendmodule\n\n"}
{"task_id": "Prob087_gates", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  output out_and,\n  output out_or,\n  output out_xor,\n  output out_nand,\n  output out_nor,\n  output out_xnor,\n  output out_anotb\n);\n\n  assign out_and = a&b;\n  assign out_or = a|b;\n  assign out_xor = a^b;\n  assign out_nand = ~(a&b);\n  assign out_nor = ~(a|b);\n  assign out_xnor = a^~b;\n  assign out_anotb = a & ~b;\n\nendmodule\n\n"}
{"task_id": "Prob125_kmap3", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output reg out\n);\n\n  always @(*) begin\n    case({a,b,c,d})\n      4'h0: out = 0;\n      4'h1: out = 0;\n      4'h3: out = 1;\n      4'h2: out = 1;\n      4'h4: out = 1'bx;\n      4'h5: out = 0;\n      4'h7: out = 0;\n      4'h6: out = 0;\n      4'hc: out = 1;\n      4'hd: out = 1'bx;\n      4'hf: out = 1;\n      4'he: out = 1;\n      4'h8: out = 1;\n      4'h9: out = 1'bx;\n      4'hb: out = 1;\n      4'ha: out = 1;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob062_bugs_mux2", "glodcode": "\nmodule RefModule (\n  input sel,\n  input [7:0] a,\n  input [7:0] b,\n  output reg [7:0] out\n);\n\n  // assign out = (~sel & a) | (sel & b);\n  assign out = sel ? a : b;\n\nendmodule\n\n"}
{"task_id": "Prob051_gates4", "glodcode": "\nmodule RefModule (\n  input [3:0] in,\n  output out_and,\n  output out_or,\n  output out_xor\n);\n\n  assign out_and = &in;\n  assign out_or = |in;\n  assign out_xor = ^in;\n\nendmodule\n\n"}
{"task_id": "Prob016_m2014_q4j", "glodcode": "\nmodule RefModule (\n  input [3:0] x,\n  input [3:0] y,\n  output [4:0] sum\n);\n\n  assign sum = x+y;\n\nendmodule\n\n"}
{"task_id": "Prob103_circuit2", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n\n  assign q = ~a^b^c^d;\n\nendmodule\n\n"}
{"task_id": "Prob039_always_if", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input sel_b1,\n  input sel_b2,\n  output out_assign,\n  output reg out_always\n);\n\n  assign out_assign = (sel_b1 & sel_b2) ? b : a;\n  always @(*) out_always = (sel_b1 & sel_b2) ? b : a;\n\nendmodule\n\n"}
{"task_id": "Prob081_7458", "glodcode": "\nmodule RefModule (\n  input p1a,\n  input p1b,\n  input p1c,\n  input p1d,\n  input p1e,\n  input p1f,\n  output p1y,\n  input p2a,\n  input p2b,\n  input p2c,\n  input p2d,\n  output p2y\n);\n\n  assign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n  assign p2y = &{p2a, p2b} | &{p2c, p2d};\n\nendmodule\n\n"}
{"task_id": "Prob120_fsm3s", "glodcode": "\nmodule RefModule (\n  input clk,\n  input in,\n  input reset,\n  output out\n);\n\n  parameter A=0, B=1, C=2, D=3;\n  reg [1:0] state;\n  reg [1:0] next;\n\n  always_comb begin\n    case (state)\n      A: next = in ? B : A;\n      B: next = in ? B : C;\n      C: next = in ? D : A;\n      D: next = in ? B : C;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= A;\n      else state <= next;\n  end\n\n  assign out = (state==D);\n\nendmodule\n\n"}
{"task_id": "Prob033_ece241_2014_q1c", "glodcode": "\nmodule RefModule (\n  input [7:0] a,\n  input [7:0] b,\n  output [7:0] s,\n  output overflow\n);\n\n  wire [8:0] sum = a+b;\n  assign s = sum[7:0];\n  assign overflow = !(a[7]^b[7]) && (a[7] != s[7]);\n\nendmodule\n\n"}
{"task_id": "Prob099_m2014_q6c", "glodcode": "\nmodule RefModule (\n  input [6:1] y,\n  input w,\n  output Y2,\n  output Y4\n);\n\n  assign Y2 = y[1]&~w;\n  assign Y4 = (y[2]|y[3]|y[5]|y[6]) & w;\n\nendmodule\n\n"}
{"task_id": "Prob065_7420", "glodcode": "\nmodule RefModule (\n  input p1a,\n  input p1b,\n  input p1c,\n  input p1d,\n  output p1y,\n  input p2a,\n  input p2b,\n  input p2c,\n  input p2d,\n  output p2y\n);\n\n  assign p1y = ~&( {p1a, p1b, p1c, p1d} );\n  assign p2y = ~&( {p2a, p2b, p2c, p2d} );\n\nendmodule\n\n"}
{"task_id": "Prob154_fsm_ps2data", "glodcode": "\nmodule RefModule (\n  input clk,\n  input [7:0] in,\n  input reset,\n  output [23:0] out_bytes,\n  output done\n);\n\n  parameter BYTE1=0, BYTE2=1, BYTE3=2, DONE=3;\n  reg [1:0] state;\n  reg [1:0] next;\n\n  wire in3 = in[3];\n\n  always_comb begin\n    case (state)\n      BYTE1: next = in3 ? BYTE2 : BYTE1;\n      BYTE2: next = BYTE3;\n      BYTE3: next = DONE;\n      DONE: next = in3 ? BYTE2 : BYTE1;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= BYTE1;\n      else state <= next;\n  end\n\n  assign done = (state==DONE);\n\n  reg [23:0] out_bytes_r;\n  always @(posedge clk)\n    out_bytes_r <= {out_bytes_r[15:0], in};\n\n  // Implementations may vary: Allow user to do anything while the output\n  // doesn't have to be valid.\n\n  assign out_bytes = done ? out_bytes_r : 'x;\n\nendmodule\n\n"}
{"task_id": "Prob070_ece241_2013_q2", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out_sop,\n  output out_pos\n);\n\n  wire pos0, pos1;\n  assign out_sop = c&d | ~a&~b&c;\n  assign pos0 = c & (~b|d)&(~a|b);\n  assign pos1 = c & (~b|d)&(~a|d);\n\n  assign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\n\nendmodule\n\n"}
{"task_id": "Prob022_mux2to1", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input sel,\n  output out\n);\n\n  assign out = sel ? b : a;\n\nendmodule\n\n"}
{"task_id": "Prob109_fsm1", "glodcode": "\nmodule RefModule (\n  input clk,\n  input in,\n  input areset,\n  output out\n);\n\n  parameter A=0, B=1;\n  reg state;\n  reg next;\n\n    always_comb begin\n    case (state)\n      A: next = in ? A : B;\n      B: next = in ? B : A;\n    endcase\n    end\n\n    always @(posedge clk, posedge areset) begin\n    if (areset) state <= B;\n        else state <= next;\n  end\n\n  assign out = (state==B);\n\nendmodule\n\n"}
{"task_id": "Prob027_fadd", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  input cin,\n  output cout,\n  output sum\n);\n\n  assign {cout, sum} = a+b+cin;\n\nendmodule\n\n"}
{"task_id": "Prob009_popcount3", "glodcode": "\nmodule RefModule (\n  input [2:0] in,\n  output [1:0] out\n);\n\n  assign out = in[0]+in[1]+in[2];\n\nendmodule\n\n"}
{"task_id": "Prob126_circuit6", "glodcode": "\nmodule RefModule (\n  input [2:0] a,\n  output reg [15:0] q\n);\n\n  always @(*)\n    case (a)\n      0: q = 4658;\n      1: q = 44768;\n      2: q = 10196;\n      3: q = 23054;\n      4: q = 8294;\n      5: q = 25806;\n      6: q = 50470;\n      7: q = 12057;\n    endcase\n\nendmodule\n\n"}
{"task_id": "Prob035_count1to10", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n\n  always @(posedge clk)\n    if (reset || q == 10)\n      q <= 1;\n    else\n      q <= q+1;\n\nendmodule\n\n"}
{"task_id": "Prob153_gshare", "glodcode": "\nmodule RefModule (\n  input clk,\n  input areset,\n\n  input predict_valid,\n  input [6:0] predict_pc,\n  output predict_taken,\n  output [6:0] predict_history,\n\n  input train_valid,\n  input train_taken,\n  input train_mispredicted,\n  input [6:0] train_history,\n  input [6:0] train_pc\n);\n\n  parameter n = 7;\n  logic [1:0] pht [2**n-1:0];\n\n  parameter [1:0] SNT = 0, LNT = 1, LT = 2, ST = 3;\n\n  logic [n-1:0] predict_history_r;\n  wire [n-1:0] predict_index = predict_history_r ^ predict_pc;\n  wire [n-1:0] train_index = train_history ^ train_pc;\n\n  always@(posedge clk, posedge areset)\n    if (areset) begin\n      for (integer i=0; i<2**n; i=i+1)\n        pht[i] = LNT;\n      predict_history_r = 0;\n        end  else begin\n      if (predict_valid)\n        predict_history_r <= {predict_history_r, predict_taken};\n      if(train_valid) begin\n        if(pht[train_index] < 3 && train_taken)\n          pht[train_index] <= pht[train_index] + 1;\n        else if(pht[train_index] > 0 && !train_taken)\n          pht[train_index] <= pht[train_index] - 1;\n        if (train_mispredicted)\n          predict_history_r <= {train_history, train_taken};\n      end\n    end\n\n  assign predict_taken = predict_valid ? pht[predict_index][1] : 1'bx;\n  assign predict_history = predict_valid ? predict_history_r : {n{1'bx}};\n\nendmodule\n\n"}
{"task_id": "Prob038_count15", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n\n  always @(posedge clk)\n    if (reset)\n      q <= 0;\n    else\n      q <= q+1;\n\nendmodule\n\n"}
{"task_id": "Prob017_mux2to1v", "glodcode": "\nmodule RefModule (\n  input [99:0] a,\n  input [99:0] b,\n  input sel,\n  output [99:0] out\n);\n\n  assign out = sel ? b : a;\n\nendmodule\n\n"}
{"task_id": "Prob139_2013_q2bfsm", "glodcode": "\nmodule RefModule (\n  input clk,\n  input resetn,\n  input x,\n  input y,\n  output f,\n  output g\n);\n\n  parameter A=0, B=1, S0=2, S1=3, S10=4, G1=5, G2=6, P0=7, P1=8;\n  reg [3:0] state, next;\n\n  always @(posedge clk) begin\n    if (~resetn) state <= A;\n    else state <= next;\n  end\n\n  always_comb begin\n    case (state)\n      A: next = B;\n      B: next = S0;\n      S0: next = x ? S1 : S0;\n      S1: next = x ? S1 : S10;\n      S10: next = x? G1 : S0;\n      G1: next = y ? P1 : G2;\n      G2: next = y ? P1 : P0;\n      P0: next = P0;\n      P1: next = P1;\n      default: next = 'x;\n    endcase\n  end\n\n  assign f = (state == B);\n  assign g = (state == G1) || (state == G2) || (state == P1);\n\nendmodule\n\n"}
{"task_id": "Prob018_mux256to1", "glodcode": "\nmodule RefModule (\n  input [255:0] in,\n  input [7:0] sel,\n  output  out\n);\n\n  assign out = in[sel];\n\nendmodule\n\n"}
{"task_id": "Prob001_zero", "glodcode": "\nmodule RefModule (\n  output zero\n);\n\n  assign zero = 1'b0;\n\nendmodule\n\n"}
{"task_id": "Prob149_ece241_2013_q4", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  input [3:1] s,\n  output reg fr3,\n  output reg fr2,\n  output reg fr1,\n  output reg dfr\n);\n\n  parameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;\n  reg [2:0] state, next;\n\n  always @(posedge clk) begin\n    if (reset) state <= A2;\n    else state <= next;\n  end\n\n  always@(*) begin\n    case (state)\n      A2: next = s[1] ? B1 : A2;\n      B1: next = s[2] ? C1 : (s[1] ? B1 : A2);\n      B2: next = s[2] ? C1 : (s[1] ? B2 : A2);\n      C1: next = s[3] ? D1 : (s[2] ? C1 : B2);\n      C2: next = s[3] ? D1 : (s[2] ? C2 : B2);\n      D1: next = s[3] ? D1 : C2;\n      default: next = 'x;\n    endcase\n  end\n  reg [3:0] fr;\n  assign {fr3, fr2, fr1, dfr} = fr;\n  always_comb begin\n    case (state)\n      A2: fr = 4'b1111;\n      B1: fr = 4'b0110;\n      B2: fr = 4'b0111;\n      C1: fr = 4'b0010;\n      C2: fr = 4'b0011;\n      D1: fr = 4'b0000;\n      default: fr = 'x;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob056_ece241_2013_q7", "glodcode": "\nmodule RefModule (\n  input clk,\n  input j,\n  input k,\n  output reg Q\n);\n\n  always @(posedge clk)\n    Q <= j&~Q | ~k&Q;\n\nendmodule\n\n"}
{"task_id": "Prob076_always_case", "glodcode": "\nmodule RefModule (\n  input [2:0] sel,\n  input [3:0] data0,\n  input [3:0] data1,\n  input [3:0] data2,\n  input [3:0] data3,\n  input [3:0] data4,\n  input [3:0] data5,\n  output reg [3:0] out\n);\n\n  always @(*) begin\n    case (sel)\n      3'h0: out = data0;\n      3'h1: out = data1;\n      3'h2: out = data2;\n      3'h3: out = data3;\n      3'h4: out = data4;\n      3'h5: out = data5;\n      default: out = 4'b0;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob040_count10", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n\n  always @(posedge clk)\n    if (reset || q == 9)\n      q <= 0;\n    else\n      q <= q+1;\n\nendmodule\n\n"}
{"task_id": "Prob113_2012_q1g", "glodcode": "\nmodule RefModule (\n  input [4:1] x,\n  output logic f\n);\n\n  always_comb begin\n    case (x)\n      4'h0: f = 1;\n      4'h1: f = 1;\n      4'h2: f = 0;\n      4'h3: f = 0;\n      4'h4: f = 1;\n      4'h5: f = 1;\n      4'h6: f = 1;\n      4'h7: f = 0;\n      4'h8: f = 0;\n      4'h9: f = 0;\n      4'ha: f = 0;\n      4'hb: f = 0;\n      4'hc: f = 1;\n      4'hd: f = 0;\n      4'he: f = 1;\n      4'hf: f = 1;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob130_circuit5", "glodcode": "\nmodule RefModule (\n  input [3:0] a,\n  input [3:0] b,\n  input [3:0] c,\n  input [3:0] d,\n  input [3:0] e,\n  output reg [3:0] q\n);\n\n  always @(*)\n    case (c)\n      0: q = b;\n      1: q = e;\n      2: q = a;\n      3: q = d;\n      default: q = 4'hf;\n    endcase\n\nendmodule\n\n"}
{"task_id": "Prob107_fsm1s", "glodcode": "\nmodule RefModule (\n  input clk,\n  input in,\n  input reset,\n  output out\n);\n\n  parameter A=0, B=1;\n  reg state;\n  reg next;\n\n    always_comb begin\n    case (state)\n      A: next = in ? A : B;\n      B: next = in ? B : A;\n    endcase\n    end\n\n    always @(posedge clk) begin\n    if (reset) state <= B;\n        else state <= next;\n  end\n\n  assign out = (state==B);\n\nendmodule\n\n"}
{"task_id": "Prob106_always_nolatches", "glodcode": "\nmodule RefModule (\n  input [15:0] scancode,\n  output reg left,\n  output reg down,\n  output reg right,\n  output reg up\n);\n\n  always @(*) begin\n    {up, left, down, right} = 0;\n    case (scancode)\n      16'he06b: left = 1;\n      16'he072: down = 1;\n      16'he074: right = 1;\n      16'he075: up = 1;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob068_countbcd", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  output [3:1] ena,\n  output reg [15:0] q\n);\n\n  wire [3:0] enable = { q[11:0]==12'h999, q[7:0]==8'h99, q[3:0] == 4'h9, 1'b1};\n  assign ena = enable[3:1];\n  always @(posedge clk)\n    for (int i=0;i<4;i++) begin\n      if (reset || (q[i*4 +:4] == 9 && enable[i]))\n        q[i*4 +:4] <= 0;\n      else if (enable[i])\n        q[i*4 +:4] <= q[i*4 +:4]+1;\n    end\n\nendmodule\n\n"}
{"task_id": "Prob021_mux256to1v", "glodcode": "\nmodule RefModule (\n  input [1023:0] in,\n  input [7:0] sel,\n  output [3:0] out\n);\n\n  assign out = {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]};\n\nendmodule\n\n"}
{"task_id": "Prob151_review2015_fsm", "glodcode": "\nmodule RefModule (\n  input clk,\n  input reset,\n  input data,\n  output reg shift_ena,\n  output reg counting,\n  input done_counting,\n  output reg done,\n  input ack\n);\n\n  typedef enum logic[3:0] {\n    S, S1, S11, S110, B0, B1, B2, B3, Count, Wait\n  } States;\n\n  States state, next;\n\n  always_comb begin\n    case (state)\n      S: next = States'(data ? S1: S);\n      S1: next = States'(data ? S11: S);\n      S11: next = States'(data ? S11 : S110);\n      S110: next = States'(data ? B0 : S);\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = Count;\n      Count: next = States'(done_counting ? Wait : Count);\n      Wait: next = States'(ack ? S : Wait);\n      default: next = States'(4'bx);\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= S;\n    else state <= next;\n  end\n\n  always_comb begin\n    shift_ena = 0; counting = 0; done = 0;\n    if (state == B0 || state == B1 || state == B2 || state == B3)\n      shift_ena = 1;\n    if (state == Count)\n      counting = 1;\n    if (state == Wait)\n      done = 1;\n\n    if (|state === 1'bx) begin\n      {shift_ena, counting, done} = 'x;\n    end\n\n  end\n\nendmodule\n\n"}
{"task_id": "Prob044_vectorgates", "glodcode": "\nmodule RefModule (\n  input [2:0] a,\n  input [2:0] b,\n  output [2:0] out_or_bitwise,\n  output out_or_logical,\n  output [5:0] out_not\n);\n\n  assign out_or_bitwise = a | b;\n  assign out_or_logical = a || b;\n  assign out_not = {~b,~a};\n\nendmodule\n\n"}
{"task_id": "Prob115_shift18", "glodcode": "\nmodule RefModule (\n  input clk,\n  input load,\n  input ena,\n  input [1:0] amount,\n  input [63:0] data,\n  output reg [63:0] q\n);\n\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else if (ena) case (amount)\n      2'b00: q <= {q[62:0], 1'b0};\n      2'b01: q <= {q[55:0], 8'b0};\n      2'b10: q <= {q[63], q[63:1]};\n      2'b11: q <= {{8{q[63]}}, q[63:8]};\n      default: q <= 64'hx;\n    endcase\n  end\n\nendmodule\n\n"}
{"task_id": "Prob075_counter_2bc", "glodcode": "\nmodule RefModule (\n  input clk,\n  input areset,\n  input train_valid,\n  input train_taken,\n  output logic [1:0] state\n);\n\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= 1;\n    else if (train_valid) begin\n      if(state < 3 && train_taken)\n        state <= state + 1;\n      else if(state > 0 && !train_taken)\n        state <= state - 1;\n    end\n  end\n\nendmodule\n\n"}
{"task_id": "Prob119_fsm3", "glodcode": "\nmodule RefModule (\n  input clk,\n  input in,\n  input areset,\n  output out\n);\n\n  parameter A=0, B=1, C=2, D=3;\n  reg [1:0] state;\n  reg [1:0] next;\n\n  always_comb begin\n  case (state)\n    A: next = in ? B : A;\n    B: next = in ? B : C;\n    C: next = in ? D : A;\n    D: next = in ? B : C;\n  endcase\n  end\n\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= A;\n      else state <= next;\n  end\n\n  assign out = (state==D);\n\nendmodule\n\n"}
{"task_id": "Prob012_xnorgate", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  output out\n);\n\n  assign out = ~(a^b);\n\nendmodule\n\n"}
{"task_id": "Prob024_hadd", "glodcode": "\nmodule RefModule (\n  input a,\n  input b,\n  output sum,\n  output cout\n);\n\n  assign {cout, sum} = a+b;\n\nendmodule\n\n"}
