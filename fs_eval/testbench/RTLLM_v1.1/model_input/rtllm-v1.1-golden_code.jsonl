{"task_id": "alu", "code": "`timescale 1ns / 1ps\n\nmodule verified_alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n    );\n    \n\n    parameter ADD = 6'b100000;\n    parameter ADDU = 6'b100001;\n    parameter SUB = 6'b100010;\n    parameter SUBU = 6'b100011;\n    parameter AND = 6'b100100;\n    parameter OR = 6'b100101;\n    parameter XOR = 6'b100110;\n    parameter NOR = 6'b100111;\n    parameter SLT = 6'b101010;\n    parameter SLTU = 6'b101011;\n    parameter SLL = 6'b000000;\n    parameter SRL = 6'b000010;\n    parameter SRA = 6'b000011;\n    parameter SLLV = 6'b000100;\n    parameter SRLV = 6'b000110;\n    parameter SRAV = 6'b000111;\n    parameter JR = 6'b001000;\n    \n    parameter LUI = 6'b001111;\n      \n    \n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n  \n    reg [32:0] res;\n    \n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign r = res[31:0];\n    \n    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; \n    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;\n    \n    always @ (a or b or aluc)\n    begin\n        case(aluc)\n            ADD: begin\n                res <= a_signed + b_signed;\n            end\n            ADDU: begin\n                res <= a + b;\n            end\n            SUB: begin \n                res <= a_signed - b_signed;\n            end\n            SUBU: begin \n                res <= a - b;\n            end\n            AND: begin\n                res <= a & b;\n            end\n            OR: begin\n                res <= a | b;\n            end\n            XOR: begin\n                res <= a ^ b;\n            end\n            NOR: begin\n                res <= ~(a | b);\n            end\n            SLT: begin\n                res <= a_signed < b_signed ? 1 : 0;\n            end\n            SLTU: begin\n                res <= a < b ? 1 : 0;\n            end\n            SLL: begin\n                res <= b << a;\n            end\n            SRL: begin\n                res <= b >> a;\n            end\n            SRA: begin\n                res <= b_signed >>> a_signed;\n            end\n            SLLV: begin\n                res <= b << a[4:0];\n            end\n            SRLV: begin\n                res <= b >> a[4:0];\n            end\n            SRAV: begin\n                res <= b_signed >>> a_signed[4:0];\n            end\n            LUI: begin\n                res <= {a[15:0], 16'h0000};\n            end\n            default:\n            begin\n                res <= 32'bz;\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "multi_pipe_4bit", "code": "`timescale 1ns/1ns\nmodule verified_multi_pipe#(\n\tparameter size = 4\n)(\n\tinput \t\t\t\t\t\tclk \t\t,   \n\tinput \t\t\t\t\t\trst_n\t\t,\n\tinput\t[size-1:0]\t\t\tmul_a\t\t,\n\tinput\t[size-1:0]\t\t\tmul_b\t\t,\n \n \toutput\treg\t[size*2-1:0]\tmul_out\t\t\n);\n\nparameter N = 2 * size;\n\nreg     [N-1:0]     sum_tmp1                ;\nreg     [N-1:0]     sum_tmp2                ;\nwire    [N-1:0]     mul_a_extend            ;\nwire    [N-1:0]     mul_b_extend            ;\n\nwire    [N-1:0]     mul_result[size-1:0]    ;\n\ngenvar i;\ngenerate\n    for(i = 0; i < size; i = i + 1) begin:add\n        assign mul_result[i] = mul_b[i] ? mul_a_extend << i : 'd0;\n    end\nendgenerate\n\nassign mul_a_extend = {{size{1'b0}}, mul_a};\nassign mul_b_extend = {{size{1'b0}}, mul_b};\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        sum_tmp1 <= 'd0;\n        sum_tmp2 <= 'd0;\n    end\n    else begin\n        sum_tmp1 <= mul_result[0] + mul_result[1];\n        sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\nend\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        mul_out <= 'd0;\n    end\n    else begin\n        mul_out <= sum_tmp1 + sum_tmp2;\n    end\nend\n\nendmodule\n\n"}
{"task_id": "multi_booth_8bit", "code": "`timescale 1ns / 1ps\n\nmodule verified_multi_booth_8bit (p, rdy, clk, reset, a, b);\n   input clk, reset;\n   input [7:0] a, b;\n   output [15:0] p;\n   output rdy;\n   \n   reg [15:0] p;\n   reg [15:0] multiplier;\n   reg [15:0] multiplicand;\n   reg rdy;\n   reg [4:0] ctr;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n    begin\n    rdy     <= 0;\n    p   <= 0;\n    ctr     <= 0;\n    multiplier <= {{8{a[7]}}, a};\n    multiplicand <= {{8{b[7]}}, b};\n    end \n    else \n    begin \n      if(ctr < 16) \n          begin\n          multiplicand <= multiplicand << 1;\n            if (multiplier[ctr] == 1)\n            begin\n                p <= p + multiplicand;\n            end\n            ctr <= ctr + 1;\n          end\n       else \n           begin\n           rdy <= 1;\n           end\n    end\n  end //End of always block\n    \nendmodule"}
{"task_id": "calendar", "code": "module verified_calendar(CLK,RST,Hours,Mins,Secs);\ninput CLK,RST;\noutput [5:0] Hours,Mins,Secs;\nreg [5:0] Hours,Mins,Secs;\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tSecs <= 0;\n\telse if (Secs == 59)\n\t\tSecs <= 0;\n\telse\n\t\tSecs <= Secs + 1;\nend\n\nalways@(posedge CLK or posedge RST) begin\n\tif (RST)\n\t\tMins <= 0;\n\telse if((Mins==59)&&(Secs==59))\n\t\tMins <= 0;\n\telse if(Secs== 59)\n\t\tMins <= Mins + 1;\n\telse\n\t\tMins <= Mins;\nend\n\nalways@(posedge CLK or posedge RST) begin\n        if (RST)\n                Hours <= 0;\n        else if((Hours == 23)&&(Mins==59)&&(Secs==59))\n                Hours <= 0;\n        else if((Mins == 59)&&(Secs==59))\n                Hours <= Hours + 1;\n        else\n                Hours <= Hours;\nend\n\nendmodule"}
{"task_id": "traffic_light", "code": "`timescale 1ns/1ns\n\nmodule verified_traffic_light\n    (\n\t\tinput rst_n, \n      input clk, \n      input pass_request,\n\t\t  output wire[7:0]clock,\n      output reg red,\n\t\t  output reg yellow,\n\t\t  output reg green\n    );\n\t\n\tparameter \tidle = 2'd0,\n\t\t\t\ts1_red = 2'd1,\n\t\t\t\ts2_yellow = 2'd2,\n\t\t\t\ts3_green = 2'd3;\n\treg [7:0] cnt;\n\treg [1:0] state;\n\treg p_red,p_yellow,p_green;\t\n\n\nalways @(posedge clk or negedge rst_n) \n    begin\n        if(!rst_n)\n        begin\n\t\t\tstate <= idle;\n\t\t\tp_red <= 1'b0;\n\t\t\tp_green <= 1'b0;\n\t\t\tp_yellow <= 1'b0;\t\t\t\n        end\n        else case(state)\n\t\tidle:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts1_red:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b1;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s3_green;\n\t\t\t\telse\n\t\t\t\t\tstate <= s1_red;\n\t\t\tend\n\t\ts2_yellow:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b0;\n\t\t\t\tp_yellow <= 1'b1;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s1_red;\n\t\t\t\telse\n\t\t\t\t\tstate <= s2_yellow;\n\t\t\tend\n\t\ts3_green:\n\t\t\tbegin\n\t\t\t\tp_red <= 1'b0;\n\t\t\t\tp_green <= 1'b1;\n\t\t\t\tp_yellow <= 1'b0;\n\t\t\t\tif (cnt == 3) \n\t\t\t\t\tstate <= s2_yellow;\n\t\t\t\telse\n\t\t\t\t\tstate <= s3_green;\n\t\t\tend\n\t\tendcase\n\tend\n \nalways @(posedge clk or negedge rst_n) \n      if(!rst_n)\n\t\t\tcnt <= 7'd10;\n\t\telse if (pass_request&&green&&(cnt>10))\n\t\t\tcnt <= 7'd10;\n\t\telse if (!green&&p_green)\n\t\t\tcnt <= 7'd60;\n\t\telse if (!yellow&&p_yellow)\n\t\t\tcnt <= 7'd5;\n\t\telse if (!red&&p_red)\n\t\t\tcnt <= 7'd10;\t\n\t\telse cnt <= cnt -1;\n assign clock = cnt;\n\nalways @(posedge clk or negedge rst_n) \n        if(!rst_n)\n\t\t\tbegin\n\t\t\t\tyellow <= 1'd0;\n\t\t\t\tred <= 1'd0;\n\t\t\t\tgreen <= 1'd0;\n\t\t\tend\n\t\telse \n\t\t\tbegin\n\t\t\t\tyellow <= p_yellow;\n\t\t\t\tred <= p_red;\n\t\t\t\tgreen <= p_green;\n\t\t\tend\t\t\n\nendmodule\n"}
{"task_id": "edge_detect", "code": "`timescale 1ns/1ns\nmodule verified_edge_detect(\n\tinput clk,\n\tinput rst_n,\n\tinput a,\n\t\n\toutput reg rise,\n\toutput reg down\n);\n\treg a0;\n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) begin\n            rise <= 1'b0;\n            down <= 1'b0;\n        end \n        else begin\n            if(a & ~a0) begin\n                rise <= 1;\n                down <= 0;\n            end \n            else if (~a & a0) begin\n                rise <= 0;\n                down <= 1;\n            end else begin\n                rise <= 0;\n                down <= 0;\n            end\n        end\n    end\n    \n    always@(posedge clk or negedge rst_n) begin\n        if(~rst_n) \n            a0 <= 0;\n        else \n            a0 <= a;\n    end\nendmodule\n"}
{"task_id": "RAM", "code": "module verified_RAM (\n\tinput clk,\n\tinput rst_n,\n\t\n\tinput write_en,\n\tinput [7:0]write_addr,\n\tinput [5:0]write_data,\n\t\n\tinput read_en,\n\tinput [7:0]read_addr,\n\toutput reg [5:0]read_data\n);\n    \n    //defination\n    reg [7 : 0] RAM [11:0];\n\n    //output \n    integer i;\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) begin\n               for(i = 0; i < 8; i = i + 1) begin\n                   RAM[i] <= 'd0;\n               end\n        end\n        else if(write_en) \n            RAM[write_addr] <= write_data;\n    end\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) \n            read_data <= 'd0;\n        else if(read_en) \n            read_data <= RAM[read_addr];\n        else \n            read_data <= 'd0;\n    end\nendmodule\n"}
{"task_id": "JC_counter", "code": "`timescale 1ns/1ns\n\nmodule verified_JC_counter(\n   input                clk ,\n   input                rst_n,\n \n   output reg [63:0]     Q  \n);\n    always@(posedge clk or negedge rst_n)begin\n        if(!rst_n) Q <= 'd0;\n        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};\n        else Q <= {1'b0, Q[63 : 1]};\n    end\nendmodule\n"}
{"task_id": "fsm", "code": "module verified_fsm(IN,MATCH,CLK,RST);\ninput IN,CLK,RST;\noutput reg MATCH;\n\nreg [2:0] ST_cr,ST_nt;\n\nparameter s0 = 3'b000;\nparameter s1 = 3'b001;\nparameter s2 = 3'b010;\nparameter s3 = 3'b011;\nparameter s4 = 3'b100;\nparameter s5 = 3'b101;\n\nalways@(posedge CLK or posedge RST) begin\n\tif(RST)\n\t\tST_cr <= s0;\n\telse\n\t\tST_cr <= ST_nt;\nend\n\nalways@(*) begin\n\tcase(ST_cr)\n\t\ts0:begin\n\t\t\tif (IN==0)\n\t\t\t\tST_nt = s0;\n\t\t\telse\n\t\t\t\tST_nt = s1;\n\t\tend\n\t\t\n\t\ts1:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n                s2:begin\n                        if (IN==0)\n                                ST_nt = s3;\n                        else\n                                ST_nt = s1;\n                end\n\n                s3:begin\n                        if (IN==0)\n                                ST_nt = s0;\n                        else\n                                ST_nt = s4;\n                end\n\n                s4:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s5;\n                end\n\n                s5:begin\n                        if (IN==0)\n                                ST_nt = s2;\n                        else\n                                ST_nt = s1;\n                end\n\n\tendcase\nend\n\nalways@(*) begin\n        if(RST)\n                MATCH  <= 0;\n        else if (ST_cr == s4 && IN == 1)\n                MATCH  <= 1;\n\telse \n\t\tMATCH  <= 0;\nend\n\nendmodule"}
{"task_id": "serial2parallel", "code": "\nmodule verified_serial2parallel(\n\tinput clk,\n\tinput rst_n,\n\tinput din_serial,\n\tinput din_valid,\n\toutput reg [7:0]dout_parallel,\n\toutput reg dout_valid\n);\n\n\treg[7:0]din_tmp;\n\treg[3:0]cnt;\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tcnt <= 0;\n\t\telse if(din_valid)\n\t\t\tcnt <= (cnt == 4'd8)?0:cnt+1'b1;\n\t\telse\t\n\t\t\tcnt <= 0;\n\tend\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)\n\t\t\tdin_tmp <= 8'b0;\n\t\telse if(din_valid && cnt <= 4'd7)\n\t\t\tdin_tmp <= {din_tmp[6:0],din_serial};\n\t\n\tend \n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdout_valid <= 1'b0;\n\t\t\tdout_parallel <= 8'b0;\n\t\tend\n\t\telse if(cnt == 4'd8)begin\n\t\t\tdout_valid <= 1'b1;\n\t\t\tdout_parallel <= din_tmp;\n\t\tend\n\t\telse begin\n\t\t\tdout_valid <= 1'b0;\n\t\tend\n\tend \n\t\nendmodule\n"}
{"task_id": "adder_8bit", "code": "module verified_adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "asyn_fifo", "code": "`timescale 1ns/1ns\n\n/***************************************RAM*****************************************/\nmodule dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)\n(\n\t input wclk\t,\n\t input wenc\t,\n\t input [$clog2(DEPTH)-1:0] waddr  ,\n\t input [WIDTH-1:0] wdata ,\n\t input rclk\t,\n\t input renc\t,\n\t input [$clog2(DEPTH)-1:0] raddr ,\n\t output reg [WIDTH-1:0] rdata \t\t\n);\n\nreg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\nalways @(posedge wclk) begin\n\tif(wenc)\n\t\tRAM_MEM[waddr] <= wdata;\nend \n\nalways @(posedge rclk) begin\n\tif(renc)\n\t\trdata <= RAM_MEM[raddr];\nend \n\nendmodule  \n\n\n/**************************************AFIFO*****************************************/\nmodule verified_asyn_fifo#(\n\tparameter\tWIDTH = 8,\n\tparameter \tDEPTH = 16\n)(\n\tinput \t\t\t\t\twclk\t, \n\tinput \t\t\t\t\trclk\t,   \n\tinput \t\t\t\t\twrstn\t,\n\tinput\t\t\t\t\trrstn\t,\n\tinput \t\t\t\t\twinc\t,\n\tinput \t\t\t \t\trinc\t,\n\tinput \t\t[WIDTH-1:0]\twdata\t,\n\n\toutput wire\t\t\t\twfull\t,\n\toutput wire\t\t\t\trempty\t,\n\toutput wire [WIDTH-1:0]\trdata\n);\n\nparameter ADDR_WIDTH = $clog2(DEPTH);\n\n\nreg \t[ADDR_WIDTH:0]\twaddr_bin;\nreg \t[ADDR_WIDTH:0]\traddr_bin;\n\nalways @(posedge wclk or negedge wrstn) begin\n\tif(~wrstn) begin\n\t\twaddr_bin <= 'd0;\n\tend \n\telse if(!wfull && winc)begin\n\t\twaddr_bin <= waddr_bin + 1'd1;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin\n\tif(~rrstn) begin\n\t\traddr_bin <= 'd0;\n\tend \n\telse if(!rempty && rinc)begin\n\t\traddr_bin <= raddr_bin + 1'd1;\n\tend\nend\n\nwire \t[ADDR_WIDTH:0]\twaddr_gray;\nwire \t[ADDR_WIDTH:0]\traddr_gray;\nreg \t[ADDR_WIDTH:0]\twptr;\nreg \t[ADDR_WIDTH:0]\trptr;\nassign waddr_gray = waddr_bin ^ (waddr_bin>>1);\nassign raddr_gray = raddr_bin ^ (raddr_bin>>1);\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\twptr <= 'd0;\n\tend \n\telse begin\n\t\twptr <= waddr_gray;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\trptr <= 'd0;\n\tend \n\telse begin\n\t\trptr <= raddr_gray;\n\tend\nend\n\nreg\t\t[ADDR_WIDTH:0]\twptr_buff;\nreg\t\t[ADDR_WIDTH:0]\twptr_syn;\nreg\t\t[ADDR_WIDTH:0]\trptr_buff;\nreg\t\t[ADDR_WIDTH:0]\trptr_syn;\nalways @(posedge wclk or negedge wrstn) begin \n\tif(~wrstn) begin\n\t\trptr_buff <= 'd0;\n\t\trptr_syn <= 'd0;\n\tend \n\telse begin\n\t\trptr_buff <= rptr;\n\t\trptr_syn <= rptr_buff;\n\tend\nend\nalways @(posedge rclk or negedge rrstn) begin \n\tif(~rrstn) begin\n\t\twptr_buff <= 'd0;\n\t\twptr_syn <= 'd0;\n\tend \n\telse begin\n\t\twptr_buff <= wptr;\n\t\twptr_syn <= wptr_buff;\n\tend\nend\n\nassign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});\nassign rempty = (rptr == wptr_syn);\n\n/***********RAM*********/\nwire \twen\t;\nwire\tren\t;\nwire \twren;//high write\nwire [ADDR_WIDTH-1:0]\twaddr;\nwire [ADDR_WIDTH-1:0]\traddr;\nassign wen = winc & !wfull;\nassign ren = rinc & !rempty;\nassign waddr = waddr_bin[ADDR_WIDTH-1:0];\nassign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\ndual_port_RAM #(.DEPTH(DEPTH),\n\t\t\t\t.WIDTH(WIDTH)\n)dual_port_RAM(\n\t.wclk (wclk),  \n\t.wenc (wen),  \n\t.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address\n\t.wdata(wdata),       \t//data_write\n\t.rclk (rclk), \n\t.renc (ren), \n\t.raddr(raddr[ADDR_WIDTH-1:0]),   \n\t.rdata(rdata)  \t\t\n);\n\nendmodule"}
{"task_id": "multi_pipe_8bit", "code": "module verified_multi_pipe_8bit#(\n    parameter size = 8\n)(\n          clk,      \n          rst_n,       \n          mul_a,       \n          mul_b, \n          mul_en_in,\n \n          mul_en_out,      \n          mul_out    \n);\n \n   input clk;           \n   input rst_n; \n   input mul_en_in;      \n   input [size-1:0] mul_a;       \n   input [size-1:0] mul_b;       \n \n   output reg mul_en_out;  \n   output reg [size*2-1:0] mul_out;    \n \n            \n   reg [2:0] mul_en_out_reg;\n always@(posedge clk or negedge rst_n)\n       if(!rst_n)begin\n            mul_en_out_reg <= 'd0;             \n            mul_en_out     <= 'd0;                           \n       end\n       else begin\n            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            \n            mul_en_out     <= mul_en_out_reg[2];                  \n       end\n \n \n    reg [7:0] mul_a_reg;\n    reg [7:0] mul_b_reg;\n  always @(posedge clk or negedge rst_n)\n         if(!rst_n) begin\n              mul_a_reg <= 'd0;\n              mul_a_reg <= 'd0;\n         end\n         else begin\n              mul_a_reg <= mul_en_in ? mul_a :'d0;\n              mul_b_reg <= mul_en_in ? mul_b :'d0;\n         end\n \n  \n     wire [15:0] temp [size-1:0];\n  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;\n  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;\n  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;\n  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;\n  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;\n  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;\n  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;\n  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; \n \n \n     reg [15:0] sum [3:0];//[size/2-1:1]\n always @(posedge clk or negedge rst_n) \n       if(!rst_n) begin\n          sum[0]  <= 'd0;\n          sum[1]  <= 'd0;\n          sum[2]  <= 'd0;\n          sum[3]  <= 'd0;\n       end \n       else begin\n          sum[0] <= temp[0] + temp[1];\n          sum[1] <= temp[2] + temp[3];\n          sum[2] <= temp[4] + temp[5];\n          sum[3] <= temp[6] + temp[7];\n       end\n \n     reg [15:0] mul_out_reg;\n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out_reg <= 'd0;\n       else \n          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n \n \n always @(posedge clk or negedge rst_n) \n       if(!rst_n)\n          mul_out <= 'd0;\n       else if(mul_en_out_reg[2])\n          mul_out <= mul_out_reg;\n       else\n          mul_out <= 'd0;\n \n          \nendmodule"}
{"task_id": "multi_16bit", "code": "module verified_multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal. Defined as 0 for chip reset; defined as 1 for reset signal inactive.\n    input start,        // Chip enable signal. \n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal. Defined as 1 indicates multiplication operation completion.\n);\n\nreg [15:0] areg;    // Multiplicand a register.\nreg [15:0] breg;    // Multiplier b register.\nreg [31:0] yout_r;  // Product register.\nreg done_r;\nreg [4:0] i;        // Shift count register.\n\n\n//------------------------------------------------\n// Data bit control\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n) i <= 5'd0;\n    else if (start && i < 5'd17) i <= i + 1'b1; \n    else if (!start) i <= 5'd0;\n\n//------------------------------------------------\n// Multiplication completion flag generation\nalways @(posedge clk or negedge rst_n)\n    if (!rst_n) done_r <= 1'b0;\n    else if (i == 5'd16) done_r <= 1'b1; // Multiplication completion flag\n    else if (i == 5'd17) done_r <= 1'b0; // Flag reset\n\nassign done = done_r;\n\n//------------------------------------------------\n// Dedicated register for shift and accumulate operation\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin \n        areg <= 16'h0000;\n        breg <= 16'h0000;\n        yout_r <= 32'h00000000;\n    end\n    else if (start) begin // Start operation\n        if (i == 5'd0) begin // Store multiplicand and multiplier\n            areg <= ain;\n            breg <= bin;\n        end\n        else if (i > 5'd0 && i < 5'd17) begin\n            if (areg[i-1]) \n            yout_r <= yout_r + ({16'h0000, breg} << (i-1)); // Accumulate and shift\n        end\n    end\nend\n\nassign yout = yout_r;\n\nendmodule"}
{"task_id": "radix2_div", "code": "`timescale 1ns/1ps\nmodule verified_radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n\n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    reg [7:0] dividend_save, divisor_save;\n    reg [15:0] SR;                  \n    reg [8 :0] NEG_DIVISOR;        \n    wire [7:0] REMAINER, QUOTIENT;\n    assign REMAINER = SR[15:8];\n    assign QUOTIENT = SR[7: 0];\n\n    wire [7:0] divident_abs;\n    wire [8:0] divisor_abs;\n    wire [7:0] remainer, quotient;\n\n    assign divident_abs = (sign & dividend[7]) ? ~dividend + 1'b1 : dividend;\n    assign remainer = (sign & dividend_save[7]) ? ~REMAINER + 1'b1 : REMAINER;\n    assign quotient = sign & (dividend_save[7] ^ divisor_save[7]) ? ~QUOTIENT + 1'b1 : QUOTIENT;\n    assign result = {remainer,quotient};\n\n    wire CO;\n    wire [8:0] sub_result;\n    wire [8:0] mux_result;\n\n    assign {CO,sub_result} = {1'b0,REMAINER} + NEG_DIVISOR;\n\n    assign mux_result = CO ? sub_result : {1'b0,REMAINER};\n\n    reg [3:0] cnt;\n    reg start_cnt;\n    always @(posedge clk) begin\n        if(rst) begin\n            SR <= 0;\n            dividend_save <= 0;\n            divisor_save <= 0;\n\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end\n        else if(~start_cnt & opn_valid & ~res_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n        \n            dividend_save <= dividend;\n            divisor_save <= divisor;\n\n            SR[15:0] <= {7'b0,divident_abs,1'b0}; \n            NEG_DIVISOR <= (sign & divisor[7]) ? {1'b1,divisor} : ~{1'b0,divisor} + 1'b1; \n        end\n        else if(start_cnt) begin\n            if(cnt[3]) begin    \n                cnt <= 0;\n                start_cnt <= 1'b0;\n                \n                SR[15:8] <= mux_result[7:0];\n                SR[0] <= CO;\n            end\n            else begin\n                cnt <= cnt + 1;\n\n                SR[15:0] <= {mux_result[6:0],SR[7:1],CO,1'b0}; \n            end\n        end\n    end\n\n    wire data_go;\n    assign data_go = res_valid & res_ready;\n    always @(posedge clk) begin\n        res_valid <= rst     ? 1'b0 :\n                     cnt[3]  ? 1'b1 :\n                     data_go ? 1'b0 : res_valid;\n    end\nendmodule\n"}
{"task_id": "right_shifter", "code": "module verified_right_shifter(clk, q,d);  \n\n    input  clk;  \n    input d;  \n    output  [7:0] q;  \n    reg   [7:0]  q; \n    initial q = 0;\n\n    always @(posedge clk)\n          begin\n            q <= (q >> 1);\n            q[7] <= d;\n          end  \n\nendmodule"}
{"task_id": "adder_pipe_64bit", "code": "module verified_adder_64bit\n#(\n    parameter DATA_WIDTH = 64,\n    parameter STG_WIDTH = 16\n)\n(\n    input clk,\n    input rst_n,\n    input i_en,\n    input [DATA_WIDTH-1:0] adda,\n    input [DATA_WIDTH-1:0] addb,\n    output [DATA_WIDTH:0] result,\n    output reg o_en\n);\n\nreg stage1;\nreg stage2;\nreg stage3;\n\nwire [STG_WIDTH-1:0] a1;\nwire [STG_WIDTH-1:0] b1;\nwire [STG_WIDTH-1:0] a2;\nwire [STG_WIDTH-1:0] b2;\nwire [STG_WIDTH-1:0] a3;\nwire [STG_WIDTH-1:0] b3;\nwire [STG_WIDTH-1:0] a4;\nwire [STG_WIDTH-1:0] b4;\n\nreg [STG_WIDTH-1:0] a2_ff1;\nreg [STG_WIDTH-1:0] b2_ff1;\n\nreg [STG_WIDTH-1:0] a3_ff1;\nreg [STG_WIDTH-1:0] b3_ff1;\nreg [STG_WIDTH-1:0] a3_ff2;\nreg [STG_WIDTH-1:0] b3_ff2;\n\nreg [STG_WIDTH-1:0] a4_ff1;\nreg [STG_WIDTH-1:0] b4_ff1;\nreg [STG_WIDTH-1:0] a4_ff2;\nreg [STG_WIDTH-1:0] b4_ff2;\nreg [STG_WIDTH-1:0] a4_ff3;\nreg [STG_WIDTH-1:0] b4_ff3;\n\nreg c1;\nreg c2;\nreg c3;\nreg c4;\n\nreg [STG_WIDTH-1:0] s1;\nreg [STG_WIDTH-1:0] s2;\nreg [STG_WIDTH-1:0] s3;\nreg [STG_WIDTH-1:0] s4;\n\nreg [STG_WIDTH-1:0] s1_ff1;\nreg [STG_WIDTH-1:0] s1_ff2;\nreg [STG_WIDTH-1:0] s1_ff3;\n\nreg [STG_WIDTH-1:0] s2_ff1;\nreg [STG_WIDTH-1:0] s2_ff2;\n\nreg [STG_WIDTH-1:0] s3_ff1;\n\nassign a1 = adda[STG_WIDTH-1:0];\nassign b1 = addb[STG_WIDTH-1:0];\nassign a2 = adda[STG_WIDTH*2-1:16];\nassign b2 = addb[STG_WIDTH*2-1:16];\nassign a3 = adda[STG_WIDTH*3-1:32];\nassign b3 = addb[STG_WIDTH*3-1:32];\nassign a4 = adda[STG_WIDTH*4-1:48];\nassign b4 = addb[STG_WIDTH*4-1:48];\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        stage1 <= 1'b0;\n        stage2 <= 1'b0;\n        stage3 <= 1'b0;\n        o_en <= 1'b0;\n    end\n    else begin\n        stage1 <= i_en;\n        stage2 <= stage1;\n        stage3 <= stage2;\n        o_en <= stage3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        a2_ff1 <= 'd0;\n        b2_ff1 <= 'd0;\n        a3_ff1 <= 'd0;\n        b3_ff1 <= 'd0;\n        a3_ff2 <= 'd0;\n        b3_ff2 <= 'd0;\n        a4_ff1 <= 'd0;\n        b4_ff1 <= 'd0;\n        a4_ff2 <= 'd0;\n        b4_ff2 <= 'd0;\n        a4_ff3 <= 'd0;\n        b4_ff3 <= 'd0;\n    end\n    else begin\n        a2_ff1 <= a2;\n        b2_ff1 <= b2;\n        a3_ff1 <= a3;\n        b3_ff1 <= b3;\n        a3_ff2 <= a3_ff1;\n        b3_ff2 <= b3_ff1;\n        a4_ff1 <= a4;\n        b4_ff1 <= b4;\n        a4_ff2 <= a4_ff1;\n        b4_ff2<= b4_ff1;\n        a4_ff3 <= a4_ff2;\n        b4_ff3 <= b4_ff2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        s1_ff1 <= 'd0;\n        s1_ff2 <= 'd0;\n        s1_ff3 <= 'd0;\n        s2_ff1 <= 'd0;\n        s2_ff2 <= 'd0;\n        s3_ff1 <= 'd0;\n    end\n    else begin\n        s1_ff1 <= s1;\n        s1_ff2 <= s1_ff1;\n        s1_ff3 <= s1_ff2;\n        s2_ff1 <= s2;\n        s2_ff2 <= s2_ff1;\n        s3_ff1 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c1 <= 1'b0;\n        s1 <= 'd0;\n    end\n    else if (i_en) begin\n        {c1, s1} <= a1 + b1;\n    end\n    else begin\n        c1 <= c1;\n        s1 <= s1;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c2 <= 1'b0;\n        s2 <= 'd0;\n    end\n    else if (stage1) begin\n        {c2, s2} <= a2_ff1 + b2_ff1 + c1;\n    end\n    else begin\n        c2 <= c2;\n        s2 <= s2;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c3 <= 1'b0;\n        s3 <= 'd0;\n    end\n    else if (stage2) begin\n        {c3, s3} <= a3_ff2 + b3_ff2 + c2;\n    end\n    else begin\n        c3 <= c3;\n        s3 <= s3;\n    end\nend\n\nalways @(posedge clk, negedge rst_n) begin\n    if (!rst_n) begin\n        c4 <= 1'b0;\n        s4 <= 'd0;\n    end\n    else if (stage3) begin\n        {c4, s4} <= a4_ff3 + b4_ff3 + c3;\n    end\n    else begin\n        c4 <= c4;\n        s4 <= s4;\n    end\nend\n\nassign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};\n\nendmodule"}
{"task_id": "div_16bit", "code": "module verified_div_16bit(\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n    );\n\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nreg [31:0] tmp_a;\nreg [31:0] tmp_b;\ninteger i;\n\nalways@(*) begin\n    a_reg = A;\n    b_reg = B;\nend\n\nalways@(*) begin\n    begin\n        tmp_a = {16'b0, a_reg};\n        tmp_b = {b_reg, 16'b0};\n        for(i = 0;i < 16;i = i+1) begin\n            tmp_a = tmp_a << 1;\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b + 1;\n            end\n            else begin\n                tmp_a = tmp_a;\n            end\n        end\n    end\nend\n\nassign odd = tmp_a[31:16];\nassign result = tmp_a[15:0];\n\nendmodule"}
{"task_id": "freq_div", "code": "module freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);\ninput CLK_in,RST;\noutput reg CLK_50,CLK_10,CLK_1;\n\nreg [3:0] cnt_10;\nreg [6:0] cnt_100;\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_50<= 1'b0;\n        end\n\telse begin\n\t\tCLK_50<= ~CLK_50;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_10<= 1'b0;\n                cnt_10<=0;\n        end\n\telse if (cnt_10==4) begin\n\t\tCLK_10<= ~CLK_10;\n                cnt_10<=0;\n        end\n        else begin\n                cnt_10<=cnt_10+1;\n        end\nend\n\nalways @(posedge CLK_in or posedge RST) begin\n\tif (RST) begin\n\t\tCLK_1<= 1'b0;\n                cnt_100<=0;\n        end\n\telse if (cnt_100==49) begin\n\t\tCLK_1<= ~CLK_1;\n                cnt_100<=0;\n        end\n        else begin\n                cnt_100<=cnt_100+1;\n        end\nend\n\nendmodule"}
{"task_id": "counter_12", "code": "`timescale 1ns/1ps\nmodule verified_counter_12 \n(\n  input rst_n,\n  input clk,\n  input valid_count,\n\n  output reg [3:0] out\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) \n\tbegin\n      out <= 4'b0000;\n    end \n\n\telse if (valid_count) \n\tbegin\n      if (out == 4'd11) \n\t  begin\n        out <= 4'b0000;\n      end \n\t  else begin\n        out <= out + 1;\n      end\n    end \n\t\n\telse begin\n      out <= out; // Pause the count when valid_count is invalid\n    end\n  end\n\nendmodule\n"}
{"task_id": "signal_generator", "code": "module verified_signal_generator(\n  input clk,\n  input rst_n,\n  output reg [4:0] wave\n);\n\n  reg [1:0] state;\n  \n  always @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n      state <= 2'b0;\n      wave <= 5'b0;\n    end\n    else begin\n      case (state)\n        2'b00:\n          begin\n            if (wave == 5'b11111)\n              state <= 2'b01;\n            else\n              wave <= wave + 1;\n          end\n          \n        2'b01:\n          begin\n            if (wave == 5'b00000)\n              state <= 2'b00;\n            else\n              wave <= wave - 1;\n          end\n      endcase\n    end\n  end\n\nendmodule"}
{"task_id": "pulse_detect", "code": "`timescale 1ns/1ns\n\nmodule verified_pulse_detect(    \n    input clk,\n    input rst_n,\n    input data_in,\n    output reg data_out\n);\n\nparameter s0 = 2'b00; // initial\nparameter s1 = 2'b01; // 0, 00\nparameter s2 = 2'b10; // 01\nparameter s3 = 2'b11; // 010\n\nreg [1:0] pulse_level1, pulse_level2;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        pulse_level1 <= s0;\n    else\n        pulse_level1 <= pulse_level2;\nend\n\nalways @(*) begin\n    case (pulse_level1)\n        s0: begin\n            if (data_in == 0)\n                pulse_level2 = s1;\n            else\n                pulse_level2 = s0;\n        end\n\n        s1: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n\n        s2: begin\n            if (data_in == 0)\n                pulse_level2 = s3;\n            else\n                pulse_level2 = s0;\n        end\n\n        s3: begin\n            if (data_in == 1)\n                pulse_level2 = s2;\n            else\n                pulse_level2 = s1;\n        end\n    endcase\nend\n\n// always @(posedge clk or negedge rst_n) begin\n//     if (~rst_n)\n//         data_out <= 0;\n//     else if (pulse_level1 == s2 && data_in == 0)\n//         begin\n//         data_out <= 1;\n//         end\n//     else\n//         data_out <= 0;\n// end\n\nalways @(*) begin\n    if (~rst_n)\n        data_out = 0;\n    else if (pulse_level1 == s2 && data_in == 0)\n        data_out = 1;\n    else\n        data_out = 0;\nend\n\nendmodule\n"}
{"task_id": "parallel2serial", "code": "`timescale 1ns/1ns\nmodule verified_parallel2serial(\n\tinput wire clk  ,\n\tinput wire rst_n  ,\n\tinput wire [3:0]d ,\n\toutput wire valid_out ,\n\toutput wire dout\n\t);\n\n\nreg [3:0] data = 'd0;\nreg [1:0]cnt;\nreg valid;\nassign dout = data[3];\nassign valid_out =valid;\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n)begin\n        data<= 'd0;\n        cnt <= 'd0;\n        valid <= 'd0;\n    end\n    else  begin\n                \n\t\tif (cnt == 'd3) begin\n\t\t\tdata <= d;\n\t\t\tcnt <= 'd0;\n\t\t\tvalid <= 1;\n\t\tend\n\t\telse begin\n\t\t\tcnt <= cnt + 'd1;\n\t\t\tvalid <= 0;\n\t\t\tdata  <= {data[2:0],data[3]};\n\t\tend\n    end\n\t\t\nend\n\n\nendmodule"}
{"task_id": "adder_16bit", "code": "module verified_adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule"}
{"task_id": "pe", "code": "module verified_pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n\n    output [31:0] c\n);\n\nreg [31:0] c;\n\nalways@(posedge clk or posedge rst)\nbegin\n\n  if(rst)\n  begin\n    c <= 0;\n  end\n\n  else\n  begin\n    c <= c + a*b;\n  end\n\nend\n\nendmodule"}
{"task_id": "adder_32bit", "code": "module verified_adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule"}
{"task_id": "synchronizer", "code": "module verified_synchronizer(\n\tinput \t\t\t\tclk_a\t, \n\tinput \t\t\t\tclk_b\t,   \n\tinput \t\t\t\tarstn\t,\n\tinput\t\t\t\tbrstn   ,\n\tinput\t\t[3:0]\tdata_in\t,\n\tinput               data_en ,\n\n\toutput reg  [3:0] \tdataout\n);\n\nreg\t[3:0]\tdata_reg;\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!arstn)\tdata_reg <= 0;\n\t\telse\tdata_reg <= data_in;\nend\nreg en_data_reg;\t\nalways@(posedge clk_a or negedge arstn)\nbegin\n\tif(!brstn)\ten_data_reg <= 0;\n\t\telse\ten_data_reg <= data_en;   \nend\n\nreg\ten_clap_one;\t//1\nreg en_clap_two;\t//2\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_one <= 0;\n\t\telse\ten_clap_one <= en_data_reg;\t\nend\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\ten_clap_two <= 0;\n\t\telse\ten_clap_two <= en_clap_one;\nend\n\nalways@(posedge clk_b or negedge brstn)\nbegin\n\tif(!brstn)\tdataout <= 0;\n\t\telse\tdataout <= (en_clap_two) ? data_reg : dataout;\nend\n\nendmodule\n"}
{"task_id": "accu", "code": "`timescale 1ns/1ns\n\nmodule verified_accu(\n    input               clk         ,   \n    input               rst_n       ,\n    input       [7:0]   data_in     ,\n    input               valid_in     ,\n \n    output  reg         valid_out     ,\n    output  reg [9:0]   data_out\n);\n    \n   reg [1:0] count;\n   wire add_cnt;\n   wire ready_add;\n   wire end_cnt;\n   reg [9:0]   data_out_reg;\n\n   assign add_cnt = ready_add;\n   assign end_cnt = ready_add && (count == 'd3);\n   \n   //count\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n          count <= 0;\n       end\n       else if(end_cnt) begin\n          count <= 0;\n       end\n       else if(add_cnt) begin\n          count <= count + 1;\n       end\n   end\n\n    //data_out_reg\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out_reg <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out_reg <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out_reg <= data_out_reg + data_in;\n      end\n   end\n\n    //data_out\n   always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        data_out <= 0;\n      end\n      else if (add_cnt && count == 0) begin\n          data_out <= data_in;\n      end\n      else if (add_cnt) begin\n          data_out <= data_out + data_in;\n      end\n   end\n\n   //ready_add\n   assign ready_add = !valid_out | valid_in;\n\n   //valid_out\n   always @(posedge clk or negedge rst_n) begin\n       if(!rst_n) begin\n           valid_out <= 0;\n       end\n       else if(end_cnt) begin\n           valid_out <= 1;\n       end\n       else begin\n           valid_out <= 0;\n       end\n   end  \n     \nendmodule"}
{"task_id": "width_8to16", "code": "`timescale 1ns/1ns\nmodule verified_width_8to16(\n\tinput \t\t\t\t   clk \t\t,   \n\tinput \t\t\t\t   rst_n\t\t,\n\tinput\t\t\t\t      valid_in\t,\n\tinput\t   [7:0]\t\t   data_in\t,\n \n \toutput\treg\t\t\tvalid_out,\n\toutput   reg [15:0]\tdata_out\n);\nreg \t[7:0]\t\tdata_lock;  //data buffer\nreg \t\t\t\tflag\t   ;\n//input data buff in data_lock\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_lock <= 'd0;\n\telse if(valid_in && !flag)\n\t\tdata_lock <= data_in;\nend\n//generate flag\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tflag <= 'd0;\n\telse if(valid_in)\n\t\tflag <= ~flag;\nend\n//generate valid_out\nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tvalid_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tvalid_out <= 1'd1;\n\telse\n\t\tvalid_out <= 'd0;\nend\n//data stitching \nalways @(posedge clk or negedge rst_n ) begin\n\tif(!rst_n) \n\t\tdata_out <= 'd0;\n\telse if(valid_in && flag)\n\t\tdata_out <= {data_lock, data_in};\nend\n\nendmodule"}
